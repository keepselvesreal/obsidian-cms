---
version: "1"
note: "초기 작성"
creator: "Claude Haiku 4.5"
created_time: "25-12-19 16:58"
---

## 압축 내용

도메인 주도 개발은 소프트웨어가 해결해야 할 문제 영역인 도메인을 체계적으로 이해하고, 도메인 전문가와 개발자가 유비쿼터스 언어로 소통하여 도메인 모델을 도출한 후, 엔티티와 밸류로 구성된 객체 모델로 구현하는 것을 기반으로 한다. [도메인이란, L18-21]

## 핵심 내용

### ⭐ 도메인이란?

도메인은 소프트웨어로 해결하고자 하는 문제 영역을 의미한다. [L18-21] 예를 들어 온라인 서점은 상품 조회, 구매, 결제, 배송 추적 등의 기능을 제공하는데, 이러한 전체 문제 영역이 도메인이다. 도메인은 여러 개의 하위 도메인으로 구성되며, 각 하위 도메인은 서로 연동하여 완전한 기능을 제공한다. [L22-40] 모든 기능을 직접 구현하지 않고 외부 시스템(외부 PG, 물류 시스템 등)을 활용하기도 한다. [L41-61]

### ⭐ 도메인 전문가와 개발자 간 지식 공유

도메인 전문가는 해당 도메인에 대한 지식과 경험을 바탕으로 요구사항을 제시한다. [L75-78] 개발자가 요구사항을 올바르게 이해하는 것이 성공적인 소프트웨어 개발의 첫 단추이다. [L79-83] 이를 위해 개발자와 전문가가 직접 대화하는 것이 중요하며, 전달자가 많을수록 정보가 왜곡되고 손실이 발생한다. [L88-91] 전문가가 제시한 요구사항도 항상 올바른 것은 아니므로, 개발자는 요구사항의 의도를 파악하고 실제로 원하는 것을 찾아야 한다. [L120-122]

### ⭐ 도메인 모델

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. [L128] 도메인 모델은 객체 모델, 상태 다이어그램, 그래프, 수학 공식 등 다양한 방식으로 표현될 수 있으며, 도메인을 이해하는 데 도움이 되면 표현 방식은 무관하다. [L194-200] 개념 모델을 바로 코드로 작성할 수 없으므로 구현 기술에 맞는 구현 모델이 필요하다. [L201-206] 각 하위 도메인은 같은 용어라도 의미가 다를 수 있으므로 하위 도메인마다 별도로 모델을 만들어야 한다. [L207-217]

### ⭐ 도메인 모델 패턴과 아키텍처

애플리케이션 아키텍처는 표현, 응용, 도메인, 인프라스트럭처의 네 개 영역으로 구성된다. [L222-228] 도메인 모델 패턴은 도메인 계층을 객체 지향 기법으로 구현하는 패턴으로, 도메인의 핵심 규칙을 도메인 객체에 구현한다. [L248-254] 예를 들어 주문의 '배송 전에만 배송지를 변경할 수 있다'는 규칙을 Order 클래스에 구현한다. [L252-264]

### ⭐ 도메인 모델 도출

도메인을 모델링할 때의 기본 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이며, 이는 요구사항에서 출발한다. [L353-354] 주문 도메인의 요구사항(최소 한 종류 이상의 상품 주문, 총 주문금액 계산, 배송지 정보 필수 등)으로부터 Order, OrderLine, ShippingInfo 클래스를 도출할 수 있다. [L354-469] 상태와 관련된 제약 조건들(출고 전에만 배송지 변경 가능, 출고 전에만 주문 취소 가능)은 OrderState 열거 타입으로 표현되며, 관련 메서드에서 검증된다. [L472-515]

### ⭐ 엔티티

엔티티는 식별자를 가진 객체로, 엔티티의 식별자는 바뀌지 않고 고유하다. [L576-589] 주문번호, 회원 ID 등이 식별자의 예이며, 두 엔티티의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다. [L590-602] 식별자는 특정 규칙에 따라 생성하거나, UUID/Nano ID를 사용하거나, 값을 직접 입력하거나, 일련번호(시퀀스, 자동 증가)를 사용한다. [L615-655]

### ⭐ 밸류 타입

밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. [L686] 예를 들어 받는 사람을 위한 Receiver(이름, 전화번호), 주소를 위한 Address(주소1, 주소2, 우편번호), 돈을 위한 Money 타입이 있다. [L691-754] 밸류 타입을 사용하면 코드의 가독성이 높아지고 도메인 의도가 명확해진다. [L756-811] 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 새로운 밸류 객체를 생성하는 불변 방식을 선호한다. [L813-856] 두 밸류 객체의 비교는 모든 속성을 비교하여 이루어진다. [L861-872] 식별자도 밸류 타입으로 표현할 수 있으며, 이를 통해 타입 자체로 의미가 드러난다. [L874-895]

### ⭐ 도메인 모델의 설계 원칙: set 메서드 제거

set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다. [L922-923] changeShippingInfo()는 배송지 정보를 변경한다는 의미를 가지지만, setShippingInfo()는 단순히 값을 설정한다는 의미만 가진다. [L930-933] set 메서드를 사용하면 객체 생성 시점에 온전하지 않은 상태가 될 수 있는 문제가 발생한다. [L939-953] 도메인 객체는 생성자를 통해 필요한 모든 데이터를 받고, set 메서드는 private 접근 범위로 제한하여 내부에서만 사용해야 한다. [L956-995]

### ⭐ 도메인 용어와 유비쿼터스 언어

도메인에서 사용하는 용어를 코드에 반영하지 않으면 코드의 의미를 해석해야 하는 부담이 생긴다. [L1011-1012] STEP1, STEP2, STEP3 같은 이름 대신 PAYMENT_WAITING, PREPARING, SHIPPED 같은 도메인 용어를 사용하면 코드가 도메인을 직접 표현한다. [L1039-1050] 에릭 에반스는 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용해야 한다는 개념으로 유비쿼터스 언어를 제시했다. [L1051-1058] 국내 개발자는 한글 도메인 용어를 영어로 번역하는 과정에서 추가적인 노력이 필요하다. [L1059-1074]

## 상세 내용

- [[#도메인과 하위 도메인]]
- [[#도메인 전문가와 요구사항]]
- [[#도메인 모델의 표현]]
- [[#아키텍처 구성]]
- [[#도메인 모델 패턴]]
- [[#요구사항에서 도메인 모델 도출하기]]
- [[#엔티티의 이해]]
- [[#엔티티 식별자 생성]]
- [[#밸류 타입의 개념과 구현]]
- [[#밸류 타입의 불변성]]
- [[#엔티티 식별자와 밸류 타입]]
- [[#도메인 모델 설계 원칙]]
- [[#유비쿼터스 언어]]

### 도메인과 하위 도메인

도메인은 소프트웨어가 해결하고자 하는 특정 문제 영역을 의미한다. [L18-21] 온라인 서점을 예로 들면, 사용자가 책을 검색하고 장바구니에 담고 구매하는 모든 과정이 포함되는 영역이 도메인이다. [L13-17]

도메인은 여러 하위 도메인으로 나뉘어진다. [L22-23] 온라인 서점 도메인은 회원, 혜택, 결제, 카탈로그, 주문, 배송, 리뷰, 정산 같은 하위 도메인으로 구성될 수 있다. [L27-34] 각 하위 도메인은 고유한 역할을 하며, 고객이 물건을 구매할 때 주문, 결제, 배송, 혜택 등 여러 하위 도메인이 연동한다. [L36-40]

모든 기능을 직접 구현하지 않는 경우도 있다. [L41-46] 많은 온라인 쇼핑몰이 자체 배송 시스템을 구축하기보다는 외부 배송 업체의 시스템을 사용하고, 결제도 결제 대행업체를 이용한다. [L42-46] 하위 도메인의 구성은 비즈니스 특성에 따라 달라진다. [L62-69]

### 도메인 전문가와 요구사항

각 영역의 전문가는 해당 도메인에 대한 지식과 경험을 바탕으로 기능 개발을 요구한다. [L75-78] 회계 담당자, AS 기사 등 다양한 도메인 전문가가 있으며, 이들의 요구사항을 올바르게 이해하는 것이 매우 중요하다. [L79-87]

요구사항 이해의 중요성은 "첫 단추"라는 비유로 설명된다. [L80-83] 첫 단추를 잘못 끼우면 모든 단추가 잘못 끼워지듯이, 요구사항을 올바르게 이해하지 못하면 요구하지 않은 엉뚱한 기능을 만들게 된다. [L80-83] 잘못 개발한 코드를 수정하는 것은 풀어서 다시 끼우는 것처럼 쉽지 않으므로 많은 노력이 필요하다. [L81-83]

요구사항을 올바르게 이해하려면 개발자와 전문가가 직접 대화하는 것이 중요하다. [L88-91] 전달자가 많으면 많을수록 정보가 왜곡되고 손실이 발생한다. [L89-91] 도메인 전문가만큼은 아니지만 이해관계자와 개발자도 도메인 지식을 갖춰야 한다. [L92-94]

NOTE: "Garbage in, Garbage out" [L100-102] - 소프트웨어 분야의 유명한 문장으로, 잘못된 값이 들어가면 잘못된 결과가 나온다는 의미이며, 이는 요구사항에도 적용된다. [L100-102]

전문가가 제시한 요구사항도 항상 올바른 것은 아니다. [L103-105] 예시: 설문 조사 시스템에서 담당자가 "목록 화면에서 일괄로 선택해서 반려 처리할 수 있는 기능"을 요구했지만, 실제로 원하던 것은 "1주일이 지난 설문 중 승인하지 않은 설문을 자동으로 반려 처리"하는 것이었다. [L105-119] 개발자는 요구사항 요청의 의도를 파악하고 실제로 원하는 것을 찾아야 한다. [L120-122]

### 도메인 모델의 표현

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. [L128] 주문 도메인의 경우, 주문(Order)은 주문번호, 지불할 총금액, 배송정보 등을 가지며, 배송정보를 변경하고 주문을 취소할 수 있다는 것을 객체 모델로 표현할 수 있다. [L129-167]

도메인 모델은 객체, 상태 다이어그램, 그래프, 수학 공식 등 다양한 방식으로 표현될 수 있다. [L172-200] 중요한 것은 도메인을 이해하는 데 도움이 되느냐 하는 것이며, 표현 방식이 무엇인지는 중요하지 않다. [L194-200]

도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다. [L201-202] 개념 모델을 바로 코드로 작성할 수 없으므로 구현 기술에 맞는 구현 모델이 필요하다. [L201-206] 개념 모델과 구현 모델은 서로 다르지만, 구현 모델이 개념 모델을 최대한 따르도록 할 수 있다. [L201-206]

각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다. [L207-210] 예: 카탈로그 도메인의 "상품"은 상품 가격, 상세 내용을 담은 정보를 의미하지만, 배송 도메인의 "상품"은 고객에게 실제 배송되는 물리적인 상품을 의미한다. [L208-210] 따라서 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 되고, 각 하위 도메인마다 별도로 모델을 만들어야 한다. [L211-217]

### 아키텍처 구성

일반적인 애플리케이션의 아키텍처는 네 개의 영역으로 구성된다. [L222-228]

| 영역 | 설명 |
|------|------|
| 표현 (Presentation) | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다. [L242-243] |
| 응용 (Application) | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. [L244-245] |
| 도메인 | 시스템이 제공할 도메인 규칙을 구현한다. [L246] |
| 인프라스트럭처 (Infrastructure) | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다. [L247] |

### 도메인 모델 패턴

도메인 모델 패턴은 도메인 계층을 객체 지향 기법으로 구현하는 패턴으로, 도메인의 핵심 규칙을 도메인 객체에 구현한다. [L248-254]

주문 도메인의 경우 "출고 전에 배송지를 변경할 수 있다"와 "주문 취소는 배송 전에만 할 수 있다"는 규칙을 Order 클래스의 메서드에 구현한다. [L252-254]

**원본 코드 (Java, L256-284):**
```java
public class Order {
    private OrderState state;
    private ShippingInfo shippingInfo;

    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        if (!state.isShippingChangeable()) {
            throw new IllegalStateException("can't change shipping in " + state);
        }
        this.shippingInfo = newShippingInfo;
    }
}

public enum OrderState {
    PAYMENT_WAITING {
        public boolean isShippingChangeable() {
            return true;
        }
    },
    PREPARING {
        public boolean isShippingChangeable() {
            return true;
        }
    },
    SHIPPED, DELIVERING, DELIVERY_COMPLETED;

    public boolean isShippingChangeable() {
        return false;
    }
}
```

**파이썬 버전:**
```python
from enum import Enum

class OrderState(Enum):
    PAYMENT_WAITING = 1
    PREPARING = 2
    SHIPPED = 3
    DELIVERING = 4
    DELIVERY_COMPLETED = 5

    def is_shipping_changeable(self):
        return self in (OrderState.PAYMENT_WAITING, OrderState.PREPARING)

class Order:
    def __init__(self):
        self.state = OrderState.PAYMENT_WAITING
        self.shipping_info = None

    def change_shipping_info(self, new_shipping_info):
        if not self.state.is_shipping_changeable():
            raise IllegalStateException("can't change shipping in " + str(self.state))
        self.shipping_info = new_shipping_info
```

OrderState는 배송지를 변경할 수 있는지를 검사할 수 있는 isShippingChangeable() 메서드를 제공한다. [L286-289] 주문 대기 중(PAYMENT_WAITING)과 상품 준비 중(PREPARING) 상태에서는 배송지를 변경할 수 있고, 그 외의 상태에서는 변경할 수 없다. [L287-289]

Order 클래스의 changeShippingInfo() 메서드는 OrderState의 isShippingChangeable() 메서드를 이용해서 변경 가능한 경우에만 배송지를 변경한다. [L291-293] 핵심은 주문과 관련된 중요한 업무 규칙을 도메인 모델인 Order나 OrderState에서 구현한다는 점이다. [L320-323]

### 요구사항에서 도메인 모델 도출하기

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이며, 이 과정은 요구사항에서 출발한다. [L353-354]

주문 도메인의 요구사항 예시: [L355-363]
- 최소 한 종류 이상의 상품을 주문해야 한다.
- 한 상품을 한 개 이상 주문할 수 있다.
- 총 주문금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 주문할 때 배송지 정보를 반드시 지정해야 한다.
- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- 출고를 하면 배송지를 변경할 수 없다.
- 출고 전에 주문을 취소할 수 있다.
- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

이 요구사항에서 알 수 있는 것은 주문이 '출고 상태로 변경하기', '배송지 정보 변경하기', '주문 취소하기', '결제 완료하기' 기능을 제공한다는 것이다. [L364-366]

**원본 코드 (OrderLine 구현, L382-402):**
```java
public class OrderLine {
    private Product product;
    private int price;
    private int quantity;
    private int amounts;

    public OrderLine(Product product, int price, int quantity) {
        this.product = product;
        this.price = price;
        this.quantity = quantity;
        this.amounts = calculateAmounts();
    }

    private int calculateAmounts() {
        return price * quantity;
    }

    public int getAmounts() { ... }
}
```

**파이썬 버전:**
```python
class OrderLine:
    def __init__(self, product, price, quantity):
        self.product = product
        self.price = price
        self.quantity = quantity
        self.amounts = self.calculate_amounts()

    def calculate_amounts(self):
        return self.price * self.quantity

    def get_amounts(self):
        return self.amounts
```

OrderLine은 한 상품을 얼마에 몇 개 살지를 담고 있고, calculateAmounts() 메서드로 구매 가격을 구하는 로직을 구현한다. [L401-402]

Order와 OrderLine의 관계: Order는 최소 한 개 이상의 OrderLine을 포함해야 하고, 총 주문 금액은 OrderLine에서 구할 수 있다. [L403-408]

ShippingInfo 클래스: 배송지 정보는 이름, 전화번호, 주소 데이터를 가진다. [L441-449]

주문할 때 배송지 정보를 반드시 지정해야 한다는 요구사항은 Order 생성자에 ShippingInfo를 함께 전달하도록 구현하고, 생성자에서 null 검사를 수행한다. [L450-469]

상태와 관련된 제약사항들: [L472-515]
- 출고를 하면 배송지 정보를 변경할 수 없다. [L474]
- 출고 전에 주문을 취소할 수 있다. [L475]

이를 구현하기 위해 주문은 최소한 출고 상태를 표현할 수 있어야 한다. OrderState 열거 타입을 사용하여 PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED, CANCELED 상태를 표현한다. [L484-487]

배송지 변경이나 주문 취소 기능은 출고 전에만 가능하다는 제약 규칙이 있으므로, changeShippingInfo()와 cancel() 메서드는 verifyNotYetShipped() 메서드를 먼저 실행한다. [L491-508]

### 엔티티의 이해

엔티티의 가장 큰 특징은 식별자를 가진다는 것이다. [L576] 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 가진다. [L576] 주문 도메인에서 각 주문은 주문번호를 가지고 있으며, 이 주문번호는 각 주문마다 서로 다르므로 주문번호가 주문의 식별자가 된다. [L577-579]

배송지 주소가 바뀌거나 상태가 바뀌더라도 주문번호는 바뀌지 않는다. [L588-589] 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 식별자는 유지된다. [L588-589]

엔티티의 식별자는 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다. [L590-591]

**원본 코드 (equals/hashCode 구현, L593-613):**
```java
public class Order {
    private String orderNumber;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (obj.getClass() != Order.class) return false;
        Order other = (Order)obj;
        if (this.orderNumber == null) return false;
        return this.orderNumber.equals(other.orderNumber);
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((orderNumber == null) ? 0 : orderNumber.hashCode());
        return result;
    }
}
```

**파이썬 버전:**
```python
class Order:
    def __init__(self, order_number):
        self.order_number = order_number

    def __eq__(self, other):
        if self is other:
            return True
        if other is None or not isinstance(other, Order):
            return False
        if self.order_number is None:
            return False
        return self.order_number == other.order_number

    def __hash__(self):
        return hash(self.order_number) if self.order_number else 0
```

### 엔티티 식별자 생성

엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다. [L615] 식별자는 다음 중 한 가지 방식으로 생성한다: [L616-620]
- 특정 규칙에 따라 생성
- UUID나 Nano ID와 같은 고유 식별자 생성기 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)

주문번호, 운송장번호, 카드번호와 같은 식별자는 특정 규칙에 따라 생성된다. [L621] 이 규칙은 도메인에 따라 다르며, 예를 들어 온라인 서점의 주문번호는 '2021112831728OOOO'와 '001-A882770000'처럼 서로 다른 구조를 가질 수 있다. [L622-624]

일반적으로 사용하는 규칙은 현재 시간과 다른 값을 함께 조합하는 것이다. [L625-628] 주의할 점은 같은 시간에 동시에 식별자를 생성해도 같은 식별자가 만들어지면 안 된다는 것이다. [L628-629]

UUID(universally unique identifier)를 사용해서 식별자를 생성할 수 있다. [L630-632] 다수의 개발 언어가 UUID 생성기를 제공하며, 자바는 java.util.UUID 클래스를 사용한다. [L631-632] 최근에는 Nano ID를 사용하는 곳도 증가하고 있다. [L639-640]

회원의 아이디나 이메일 같은 식별자는 값을 직접 입력하며, 사용자가 직접 입력하는 값이기 때문에 식별자를 중복해서 입력하지 않도록 사전에 방지하는 것이 중요하다. [L641-642]

일련번호 방식은 주로 데이터베이스가 제공하는 자동 증가 기능을 사용한다. [L647-649] 오라클의 시퀀스나 MySQL의 자동 증가 칼럼이 예이다. [L648-649]

자동 증가 칼럼을 제외한 다른 방식은 다음 코드처럼 식별자를 먼저 만들고 엔티티 객체를 생성할 때 식별자를 전달한다: [L650-655]

```
String orderNumber = orderRepository.generateOrderNumber();
Order order = new Order(orderNumber, ....);
orderRepository.save(order);
```

자동 증가 칼럼은 DB 테이블에 데이터를 삽입해야 비로소 값을 알 수 있으므로 테이블에 데이터를 추가하기 전에는 식별자를 알 수 없다. [L656-657] 이는 엔티티 객체를 생성할 때 식별자를 전달할 수 없음을 의미한다. [L657-662]

### 밸류 타입의 개념과 구현

ShippingInfo 클래스는 받는 사람과 주소에 대한 데이터를 가지고 있다. [L670] 구체적으로:
- receiverName, receiverPhoneNumber 필드는 받는 사람을 의미
- shippingAddress1, shippingAddress2, shippingZipcode 필드는 주소를 의미

[L682-685]

밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. [L686] 받는 사람을 위한 Receiver 밸류 타입: [L691-704]

```
public class Receiver {
    private String name;
    private String phoneNumber;

    public Receiver(String name, String phoneNumber) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    public String getName() { return name; }
    public String getPhoneNumber() { return phoneNumber; }
}
```

Receiver는 "받는 사람"이라는 도메인 개념을 표현한다. [L705-708]

ShippingInfo 주소 관련 데이터도 Address 밸류 타입을 사용해서 명확하게 표현할 수 있다: [L709-730]

```
public class Address {
    private String address1;
    private String address2;
    private String zipcode;

    public Address(String address1, String address2, String zipcode) {
        this.address1 = address1;
        this.address2 = address2;
        this.zipcode = zipcode;
    }
    // get 메서드
}

public class ShippingInfo {
    private Receiver receiver;
    private Address address;
    // 생성자, get 메서드
}
```

배송정보가 받는 사람과 주소로 구성된다는 것을 쉽게 알 수 있다. [L725-726]

밸류 타입이 꼭 두 개 이상의 데이터를 가져야 하는 것은 아니다. [L732-733] 의미를 명확하게 표현하기 위해 밸류 타입을 사용하는 경우도 있다. 좋은 예가 OrderLine이다. [L733-734]

OrderLine의 price와 amounts는 int 타입의 숫자를 사용하지만 이들은 "돈"을 의미하는 값이다. [L740-742] 따라서 "돈"을 의미하는 Money 타입을 만들어 사용하면 코드를 이해하는 데 도움이 된다: [L743-754]

**원본 코드 (Java, L743-773):**
```java
public class Money {
    private int value;

    public Money(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }

    public Money add(Money money) {
        return new Money(this.value + money.value);
    }

    public Money multiply(int multiplier) {
        return new Money(value * multiplier);
    }
}
```

**파이썬 버전:**
```python
class Money:
    def __init__(self, value):
        self.value = value

    def get_value(self):
        return self.value

    def add(self, money):
        return Money(self.value + money.value)

    def multiply(self, multiplier):
        return Money(self.value * multiplier)
```

Money 타입을 사용하면 price와 amounts가 금액을 의미한다는 것을 쉽게 알 수 있다. [L755-756]

OrderLine을 Money 타입으로 변경하면: [L757-761]

```
public class OrderLine {
    private Product product;
    private Money price;
    private int quantity;
    private Money amounts;
}
```

Money를 사용하는 코드는 "정수 타입 연산"이 아니라 "돈 계산"이라는 의미로 작성할 수 있다. [L774-775]

### 밸류 타입의 불변성

밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다. [L813-815] Money 클래스의 add() 메서드는 Money를 새로 생성한다: [L814-815]

```
public Money add(Money money) {
    return new Money(this.value + money.value);
}
// value를 변경할 수 있는 메서드 없음
```

Money처럼 데이터 변경 기능을 제공하지 않는 타입을 불변(immutable)이라고 표현한다. [L823]

밸류 타입을 불변으로 구현하는 여러 이유가 있으며, 가장 중요한 이유는 안전한 코드를 작성할 수 있다는 데 있다. [L824-825] OrderLine을 생성할 때 Money 객체를 전달하는데: [L830-831]

```
Money price = ...;
OrderLine line = new OrderLine(product, price, quantity);
// 만약 price.setValue(0)으로 값을 변경할 수 있다면?
```

만약 Money가 setValue()와 같은 메서드를 제공해서 값을 변경할 수 있다면, OrderLine의 price 값이 잘못 반영되는 상황이 발생한다: [L833-840]

```
Money price = new Money(1000)
OrderLine line = new OrderLine(product, price, 2);
// [price=1000, quantity=2, amounts=2000]
price.setValue(2000);
// [price=2000, quantity=2, amounts=2000] ← 문제!
```

이런 문제가 발생하는 것을 방지하려면 OrderLine 생성자가 새로운 Money 객체를 생성해야 한다: [L841-852]

```
public class OrderLine {
    private Money price;

    public OrderLine(Product product, Money price, int quantity) {
        this.product = product;
        // Money가 불변 객체가 아니라면,
        // price 파라미터가 변경될 때 발생하는 문제를 방지하기 위해
        // 데이터를 복사한 새로운 객체를 생성해야 한다.
        this.price = new Money(price.getValue());
        this.quantity = quantity;
        this.amounts = calculateAmounts();
    }
}
```

Money가 불변이면 이런 코드를 작성할 필요가 없다. [L854-855] Money의 데이터를 바꿀 수 없기 때문에 파라미터로 전달받은 price를 안전하게 사용할 수 있다. [L854-855]

불변 객체는 참조 투명성과 스레드에 안전한 특징을 가진다. [L859-860]

두 밸류 객체를 비교할 때는 모든 속성이 같은지 비교한다: [L861-872]

**원본 코드 (Java, L862-872):**
```java
public class Receiver {
    private String name;
    private String phoneNumber;

    public boolean equals(Object other) {
        if (other == null) return false;
        if (this == other) return true;
        if (!(other instanceof Receiver)) return false;
        Receiver that = (Receiver)other;
        return this.name.equals(that.name) &&
               this.phoneNumber.equals(that.phoneNumber);
    }
}
```

**파이썬 버전:**
```python
class Receiver:
    def __init__(self, name, phone_number):
        self.name = name
        self.phone_number = phone_number

    def __eq__(self, other):
        if other is None:
            return False
        if self is other:
            return True
        if not isinstance(other, Receiver):
            return False
        return (self.name == other.name and
                self.phone_number == other.phone_number)
```

### 엔티티 식별자와 밸류 타입

엔티티 식별자의 실제 데이터는 String 같은 문자열로 구성되는 경우가 많다. [L875-877] 신용카드 번호는 16개의 숫자로 구성된 문자열이며, 많은 온라인 서비스에서 회원을 구분할 때 사용하는 이메일 주소도 문자열이다. [L875-877]

이런 식별자는 단순한 문자열이 아니라 도메인에서 특별한 의미를 지니는 경우가 많기 때문에 식별자를 위한 밸류 타입을 사용해서 의미가 잘 드러나도록 할 수 있다. [L878-881]

예를 들어 주문번호를 표현하기 위해 Order의 식별자 타입으로 String 대신 OrderNo 밸류 타입을 사용하면 타입을 통해 해당 필드가 주문번호라는 것을 알 수 있다: [L880-891]

```
public class Order {
    // OrderNo 타입 자체로 id가 주문번호임을 알 수 있다.
    private OrderNo id;

    public OrderNo getId() {
        return id;
    }
}
```

OrderNo 대신에 String 타입을 사용한다면 'id'라는 이름만으로는 해당 필드가 주문번호인지를 알 수 없다. [L892-893] 필드의 의미가 드러나도록 하려면 'id'라는 필드 이름 대신 'orderNo'라는 필드 이름을 사용해야 한다. [L893] 반면에 식별자를 위해 OrderNo 타입을 만들면 타입 자체로 주문번호라는 것을 알 수 있으므로 필드 이름이 'id'여도 실제 의미를 찾는 것은 어렵지 않다. [L894-895]

### 도메인 모델 설계 원칙: set 메서드 제거

get/set 메서드를 습관적으로 추가할 때가 있다. [L897-898] 사용자 정보를 담는 UserInfo 클래스를 작성할 때 다음과 같이 데이터 필드에 대한 get/set 메서드를 습관처럼 작성할 수 있다: [L898-918]

get/set 메서드를 습관적으로 만드는 가장 큰 이유는 프로그래밍에 입문할 때 읽은 책의 예제 코드이다. [L919-921] 처음 프로그래밍을 배울 때 익힌 예제 코드를 그대로 따라 하다 보니 상황에 상관없이 get/set 메서드를 습관적으로 추가한다. [L921-922]

도메인 모델에 get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇이다. [L922-923] 특히 set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다. [L922-923]

Order의 메서드를 set 메서드로 변경해보면: [L923-929]

```
public class Order {
    public void setShippingInfo(ShippingInfo newShipping) { ... }
    public void setOrderState(OrderState state) {...}
}
```

changeShippingInfo()가 배송지 정보를 새로 변경한다는 의미를 가졌다면, setShippingInfo() 메서드는 단순히 배송지 값을 설정한다는 의미만 가진다. [L930-932] completePayment()는 결제를 완료했다는 의미를 가지는 반면에 setOrderState()는 단순히 주문 상태 값을 설정한다는 의미만 가진다. [L931-933]

구현할 때도 completePayment()는 결제 완료 처리 코드를 구현하니까 결제 완료와 관련된 도메인 지식을 코드로 구현하는 것이 자연스럽다. [L934-936] setOrderState()는 단순히 상태 값만 변경할지 아니면 상태값에 따라 다른 처리를 위한 코드를 함께 구현할지 애매하다. [L935-937] 습관적으로 작성한 set 메서드는 필드값만 변경하고 끝나기 때문에 상태 변경과 관련된 도메인 지식이 코드에서 사라지게 된다. [L937-938]

set 메서드의 또 다른 문제는 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수 있다는 것이다. [L939-940]

```
// set 메서드로 데이터를 전달하도록 구현하면
// 처음 Order를 생성하는 시점에 order는 완전하지 않다.
Order order = new Order();
// set 메서드로 필요한 모든 값을 전달해야 함
order.setOrderLine(lines);
order.setShippingInfo(shippingInfo);
// 주문자(Orderer)를 설정하지 않은 상태에서 주문 완료 처리
order.setState(OrderState.PREPARING);
```

위 코드는 주문자 설정을 누락하고 있다. [L950-951] 주문자 정보를 담고 있는 필드인 orderer가 null인 상황에서 order.setState() 메서드를 호출해서 상품 준비 중 상태로 바꾼 것이다. [L951-952]

도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다. [L956-957] 즉 생성자를 통해 필요한 데이터를 모두 받아야 한다. [L957]

```
Order order = new Order(orderer, lines, shippingInfo, OrderState.PREPARING);
```

생성자로 필요한 것을 모두 받으므로 다음처럼 생성자를 호출하는 시점에 필요한 데이터가 올바른지 검사할 수 있다: [L959-988]

**원본 코드 (Java, L961-988):**
```java
public class Order {
    public Order(Orderer orderer, List<OrderLine> orderLines,
                 ShippingInfo shippingInfo, OrderState state) {
        setOrderer(orderer);
        setOrderLines(orderLines);
        // 다른 값 설정
    }

    private void setOrderer(Orderer orderer) {
        if (orderer == null) throw new IllegalArgumentException("no orderer");
        this.orderer = orderer;
    }

    private void setOrderLines(List<OrderLine> orderLines) {
        verifyAtLeastOneOrMoreOrderLines(orderLines);
        this.orderLines = orderLines;
        calculateTotalAmounts();
    }

    private void verifyAtLeastOneOrMoreOrderLines(List<OrderLine> orderLines) {
        if (orderLines == null || orderLines.isEmpty()) {
            throw new IllegalArgumentException("no OrderLine");
        }
    }

    private void calculateTotalAmounts() {
        this.totalAmounts = orderLines.stream()
                                      .mapToInt(x -> x.getAmounts())
                                      .sum();
    }
}
```

**파이썬 버전:**
```python
class Order:
    def __init__(self, orderer, order_lines, shipping_info, state):
        self._set_orderer(orderer)
        self._set_order_lines(order_lines)
        # 다른 값 설정

    def _set_orderer(self, orderer):
        if orderer is None:
            raise ValueError("no orderer")
        self.orderer = orderer

    def _set_order_lines(self, order_lines):
        self._verify_at_least_one_or_more_order_lines(order_lines)
        self.order_lines = order_lines
        self._calculate_total_amounts()

    def _verify_at_least_one_or_more_order_lines(self, order_lines):
        if order_lines is None or len(order_lines) == 0:
            raise ValueError("no OrderLine")

    def _calculate_total_amounts(self):
        self.total_amounts = sum(line.get_amounts() for line in self.order_lines)
```

이 코드의 set 메서드는 앞서 언급한 set 메서드와 중요한 차이점이 있으며, 그것은 바로 접근 범위가 private이라는 점이다. [L989-991] 이 코드에서 set 메서드는 클래스 내부에서 데이터를 변경할 목적으로만 사용된다. [L989-991]

불변 밸류 타입을 사용하면 자연스럽게 밸류 타입에는 set 메서드를 구현하지 않는다. [L993-994] set 메서드를 구현해야 할 특별한 이유가 없다면 불변 타입의 장점을 살릴 수 있도록 밸류 타입은 불변으로 구현한다. [L994-995]

### 유비쿼터스 언어

코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요하다. [L1011] 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다. [L1011-1012]

OrderState를 다음과 같이 구현했다고 가정해보자: [L1013-1016]

```
public OrderState {
    STEP1, STEP2, STEP3, STEP4, STEP5, STEP6
}
```

실제 주문 상태는 '결제 대기 중', '상품 준비 중', '출고 완료됨', '배송중', '배송완료됨', '주문 취소됨'인데 이 코드는 개발자가 전체 상태를 6단계로 보고 코드로 표현한 것이다. [L1017-1019]

이 개발자는 Order 코드를 다음과 같이 작성할 가능성이 높다: [L1019-1029]

```
public class Order {
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyStep1OrStep2();
        setShippingInfo(newShippingInfo);
    }

    private void verifyStep1OrStep2() {
        if (state != OrderState.STEP1 && state != OrderState.STEP2)
            throw new IllegalStateException("aleady shipped");
    }
}
```

배송지 변경은 '출고 전에 가능한데 이 코드의 verifyStep1OrStep2라는 이름에는 중요한 도메인 규칙이 드러나지 않는다. [L1030-1031] 그저 STEP1, STEP2인지 검사만 할 뿐이다. [L1031] 실제 이 코드의 의미를 이해하려면 STEP1, STEP2가 각각 '결제 대기 중' 상태와 '상품 준비 중' 상태를 의미한다는 것을 알아야 한다. [L1035-1036]

기획자나 온라인 쇼핑 도메인 전문가가 개발자와의 업무 회의에서 '출고전'이라는 단어를 사용하면 개발자는 머릿속으로 '출고 전은 STEP1, STEP2'라고 도메인 지식을 코드로 해석해야 한다. [L1036-1038]

도메인 용어를 사용해서 OrderState를 구현하면 이런 불필요한 변환 과정을 거치지 않아도 된다: [L1039-1043]

```
public enum OrderState {
    PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED;
}
```

STEP1, STEP2, STEP3이 아닌 PAYMENT_WAITING, PREPARING, SHIPPED와 같이 도메인에서 사용하는 용어를 최대한 코드에 반영하면 '출고(SHIPPED) 전은 결제 대기 중(PAYMENT_WAITING)이나 상품 준비 중(PREPARING)'이라고 바로 이해할 수 있다. [L1044-1047] 코드를 도메인 용어로 해석하거나 도메인 용어를 코드로 해석하는 과정이 줄어든다. [L1047-1048] 이는 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 줄여준다. [L1048-1049]

최대한 도메인 용어를 사용해서 도메인 규칙을 코드로 작성하게 되므로 의미를 변환하는 과정에서 발생하는 버그도 줄어든다. [L1049-1050]

에릭 에반스는 도메인 주도 설계에서 언어의 중요함을 강조하기 위해 유비쿼터스 언어(ubiquitous Language)라는 용어를 사용했다. [L1051-1052] 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용한다. [L1052-1054] 이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다. [L1053-1055]

시간이 지날수록 도메인에 대한 이해가 높아지는데 새롭게 이해한 내용을 잘 표현할 수 있는 용어를 찾아내고 이를 다시 공통의 언어로 만들어 다 같이 사용한다. [L1056-1057] 새로 발견한 용어는 코드나 문서에도 반영해서 산출물에 최신 모델을 적용한다. [L1057-1058]

도메인 용어는 좋은 코드를 만드는 데 매우 중요한 요소이지만 국내 개발자는 이 점에 있어 불리한 점이 있다. [L1059-1060] 바로 영어다. [L1060] 분야의 특성상 알파벳과 숫자를 사용해서 클래스, 필드, 메서드 등의 이름을 작성하게 되므로 도메인 용어를 영어로 해석하는 노력이 필요하다. [L1060-1065]

도메인에서 사용하는 용어의 의미를 명확하게 전달하는 영단어를 찾기 힘든 경우도 있고, 반대로 비슷한 의미의 영단어가 많으면 각 단어의 뉘앙스나 미세한 차이를 몰라서 선택하기 어려울 때도 있다. [L1066-1069] 예를 들어 도메인 용어의 '상태'를 코드로 표현할 때 'state'와 'status' 중 어떤 단어를 사용할지 고민해야 하고, '종류'를 표현하기 위해 'kind'와 'type' 중 어떤 단어가 맞는지 고심할 때도 있다. [L1068-1069]

알맞은 영단어를 찾는 것은 쉽지 않은 일이지만 시간을 들여 찾는 노력을 해야 한다. [L1071-1072] 한영사전을 사용해서 적당한 단어를 찾는 노력을 하지 않고 도메인에 어울리지 않은 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다. [L1072-1073] 그러니 도메인 용어에 알맞은 단어를 찾는 시간을 아까워하지 말자. [L1073-1074]

## 화제

- ⭐ 도메인이란?
- ⭐ 하위 도메인
- ⭐ 도메인 전문가와 개발자의 소통
- ⭐ 요구사항 분석
- ⭐ Garbage in, Garbage out
- ⭐ 도메인 모델
- ⭐ 개념 모델과 구현 모델
- ⭐ 아키텍처의 4개 영역
- 도메인 모델 패턴
- OrderState 열거 타입
- ⭐ 요구사항 도출
- Order 클래스
- OrderLine 클래스
- ShippingInfo 클래스
- ⭐ 엔티티
- 엔티티의 식별자
- 식별자 생성 방식
- UUID
- 일련번호
- ⭐ 밸류 타입
- Receiver 밸류 타입
- Address 밸류 타입
- Money 밸류 타입
- ⭐ 불변 객체
- 참조 투명성
- 밸류 타입의 equals() 메서드
- ⭐ 엔티티 식별자와 밸류 타입
- OrderNo 밸류 타입
- ⭐ set 메서드의 문제점
- 도메인 객체의 완전성
- 생성자를 통한 데이터 전달
- private set 메서드
- DTO의 get/set 메서드
- ⭐ 유비쿼터스 언어
- 도메인 용어의 중요성
- 영어 번역의 어려움
