---
version: "1"
note:
created_date: 25-12-18 07:43
hasEnglishVersion: true
---

## 목차
- [[#1. 좋은 단위 테스트의 특징]]
- [[#2. 좋은 테스트 작성 방법]]
- [[#3. 단위 테스트 체크리스트]]
- [[#4. 테스트 실패 시 대응 프로세스]]

---

## 1. 좋은 단위 테스트의 특징

### 1.1 핵심 속성 (Ch.1, pp.15-16)

**모든 좋은 자동화 테스트가 가져야 할 속성:**
- **이해하기 쉬운 의도**: 테스트 작성자의 의도가 명확해야 함
- **읽고 쓰기 쉬움**: 코드가 간결하고 직관적
- **자동화**: 버튼 하나로 실행 가능
- **일관된 결과**: 코드 변경 없이 항상 같은 결과 반환
- **유용하고 실행 가능한 결과**: 실패 시 명확한 정보 제공
- **누구나 실행 가능**: 팀 누구나 쉽게 실행
- **실패 시 디버깅 용이**: 기대값과 실제값을 쉽게 파악

**좋은 단위 테스트만의 추가 속성:**
- **빠른 실행 속도**
- **완전한 제어**: 테스트 대상 코드를 완전히 제어
- **완전한 격리**: 다른 테스트와 독립적으로 실행
- **메모리 내 실행**: 파일시스템, 네트워크, DB 불필요
- **동기적/선형적 실행**: 가능한 한 멀티스레드 배제

### 1.2 신뢰성(Trust) 기준 (Ch.7, pp.150-151)

**신뢰할 수 있는 테스트:**
- ✅ 실패 시 진짜 버그를 걱정하게 됨
- ✅ 통과 시 안심하고 수동 테스트가 필요 없음

**신뢰할 수 없는 테스트:**
- ❌ 실패해도 false positive라 생각함
- ❌ 통과해도 "혹시 몰라" 수동 테스트를 함

---

## 2. 좋은 테스트 작성 방법

### 2.1 엔트리 포인트와 엑싯 포인트 (Ch.1, pp.6-11)

**개념:**
- **엔트리 포인트**: 작업 단위의 시작점 (함수 호출)
- **엑싯 포인트**: 작업 단위의 결과
  - 반환값 (return value)
  - 상태 변경 (state change)
  - 서드파티 호출 (third-party call)

**JavaScript 예제:**
```javascript
// 3가지 엑싯 포인트를 가진 함수
let total = 0;

const sum = (numbers) => {
  const [a, b] = numbers.split(',');
  
  // 엑싯 포인트 1: 서드파티 호출
  logger.info('calculation', { firstNumWas: a, secondNumWas: b });
  
  const result = parseInt(a) + parseInt(b);
  
  // 엑싯 포인트 2: 상태 변경
  total += result;
  
  // 엑싯 포인트 3: 반환값
  return result;
};
```

**Python 버전:**
```python
# 3가지 엑싯 포인트를 가진 함수
total = 0

def sum_numbers(numbers: str) -> int:
    a, b = numbers.split(',')
    
    # 엑싯 포인트 1: 서드파티 호출
    logger.info('calculation', {'firstNumWas': a, 'secondNumWas': b})
    
    result = int(a) + int(b)
    
    # 엑싯 포인트 2: 상태 변경
    global total
    total += result
    
    # 엑싯 포인트 3: 반환값
    return result
```

**베스트 프랙티스:**
> 각 엑싯 포인트마다 별도의 테스트를 작성하라 (Ch.1, p.10)

---

### 2.2 테스트에서 로직 제거 (Ch.7, pp.153-156)

#### 2.2.1 동적 기대값 생성 피하기

**❌ 안티패턴: 테스트에 로직이 있음**

```javascript
// 나쁜 예 - 프로덕션 로직을 테스트에서 반복
it("returns correct greeting for name", () => {
  const name = "abc";
  const result = makeGreeting(name);
  expect(result).toBe("hello" + name);  // ❌ 프로덕션 로직 반복
});
```

```python
# 나쁜 예 - 프로덕션 로직을 테스트에서 반복
def test_greeting_bad():
    name = "abc"
    result = make_greeting(name)
    assert result == "hello" + name  # ❌ 프로덕션 로직 반복
```

**✅ 베스트 프랙티스: 하드코딩된 기대값**

```javascript
// 좋은 예 - 하드코딩된 값으로 검증
it("returns correct greeting for name", () => {
  const result = makeGreeting("abc");
  expect(result).toBe("hello abc");  // ✅ 하드코딩된 값
});
```

```python
# 좋은 예 - 하드코딩된 값으로 검증
def test_greeting_good():
    result = make_greeting("abc")
    assert result == "hello abc"  # ✅ 하드코딩된 값
```

#### 2.2.2 루프와 조건문 피하기

**❌ 안티패턴: 여러 시나리오를 한 테스트에**

```javascript
// 나쁜 예 - 루프와 조건문 사용
it("correctly finds out if it is a name", () => {
  const namesToTest = ["firstOnly", "first second", ""];
  
  namesToTest.forEach((name) => {
    const result = isName(name);
    if (name.includes(" ")) {
      expect(result).toBe(true);
    } else {
      expect(result).toBe(false);
    }
  });
});
```

```python
# 나쁜 예 - 루프와 조건문 사용
def test_is_name_bad():
    names_to_test = ["firstOnly", "first second", ""]
    
    for name in names_to_test:
        result = is_name(name)
        if " " in name:
            assert result == True
        else:
            assert result == False
```

**✅ 베스트 프랙티스: 시나리오별 테스트 분리**

```javascript
// 좋은 예 - 각 시나리오를 별도 테스트로
describe("isName", () => {
  it("returns true for full name", () => {
    const result = isName("first second");
    expect(result).toBe(true);
  });
  
  it("returns false for single word", () => {
    const result = isName("firstOnly");
    expect(result).toBe(false);
  });
  
  it("returns false for empty string", () => {
    const result = isName("");
    expect(result).toBe(false);
  });
});
```

```python
# 좋은 예 - 각 시나리오를 별도 테스트로
class TestIsName:
    def test_returns_true_for_full_name(self):
        result = is_name("first second")
        assert result == True
    
    def test_returns_false_for_single_word(self):
        result = is_name("firstOnly")
        assert result == False
    
    def test_returns_false_for_empty_string(self):
        result = is_name("")
        assert result == False
```

---

### 2.3 어설션 작성 (Ch.7, pp.158-160)

#### 2.3.1 한 테스트에서 한 가지만 검증

**❌ 안티패턴: 여러 관심사(concern)를 한 테스트에서**

```javascript
// 나쁜 예 - 두 가지 관심사를 동시에 검증
it("works", () => {
  const callback = jest.fn();
  const result = trigger(1, 2, callback);
  
  expect(result).toBe(3);  // 관심사 1: 반환값
  expect(callback).toHaveBeenCalledWith("I'm triggered");  // 관심사 2: 콜백 호출
});
```

```python
# 나쁜 예 - 두 가지 관심사를 동시에 검증
def test_works_bad():
    callback = Mock()
    result = trigger(1, 2, callback)
    
    assert result == 3  # 관심사 1: 반환값
    callback.assert_called_with("I'm triggered")  # 관심사 2: 콜백 호출
```

**✅ 베스트 프랙티스: 관심사별 테스트 분리**

```javascript
// 좋은 예 - 각 관심사를 별도 테스트로
describe("trigger", () => {
  it("triggers a given callback", () => {
    const callback = jest.fn();
    trigger(1, 2, callback);
    expect(callback).toHaveBeenCalledWith("I'm triggered");
  });
  
  it("sums up given values", () => {
    const result = trigger(1, 2, jest.fn());
    expect(result).toBe(3);
  });
});
```

```python
# 좋은 예 - 각 관심사를 별도 테스트로
class TestTrigger:
    def test_triggers_callback(self):
        callback = Mock()
        trigger(1, 2, callback)
        callback.assert_called_with("I'm triggered")
    
    def test_sums_up_values(self):
        result = trigger(1, 2, Mock())
        assert result == 3
```

#### 2.3.2 예외: 단일 관심사의 여러 속성

**✅ 허용됨: 같은 관심사의 여러 속성 검증** (Ch.7, p.160)

```javascript
// 허용됨 - 같은 관심사(person 객체 생성)의 여러 속성
it("creates person given passed in values", () => {
  const result = makePerson("name", 1);
  
  expect(result.name).toBe("name");
  expect(result.age).toBe(1);
  // 둘 다 "person 객체가 올바르게 생성되었는가"라는 하나의 관심사
});
```

```python
# 허용됨 - 같은 관심사의 여러 속성
def test_creates_person():
    result = make_person("name", 1)
    
    assert result.name == "name"
    assert result.age == 1
    # 둘 다 "person 객체가 올바르게 생성되었는가"라는 하나의 관심사
```

---

### 2.4 유지보수성 향상 (Ch.8)

#### 2.4.1 팩토리 함수로 API 변경 대응 (Ch.8, pp.167-169)

**❌ 안티패턴: 테스트에서 직접 객체 생성**

```javascript
// 나쁜 예 - 생성자 시그니처 변경 시 모든 테스트 수정 필요
it("passes with zero rules", () => {
  const verifier = new PasswordVerifier([], { info: jest.fn() });
  const result = verifier.verify("any input");
  expect(result).toBe(true);
});

it("fails with one failing rule", () => {
  const verifier = new PasswordVerifier([() => false], { info: jest.fn() });
  const result = verifier.verify("any input");
  expect(result).toBe(false);
});
```

```python
# 나쁜 예 - 생성자 시그니처 변경 시 모든 테스트 수정 필요
def test_passes_with_zero_rules_bad():
    verifier = PasswordVerifier([], FakeLogger())
    result = verifier.verify("any input")
    assert result == True

def test_fails_with_one_failing_rule_bad():
    verifier = PasswordVerifier([lambda x: False], FakeLogger())
    result = verifier.verify("any input")
    assert result == False
```

**✅ 베스트 프랙티스: 팩토리 함수 사용**

```javascript
// 좋은 예 - 팩토리 함수로 생성 로직 중앙화
const makeFakeLogger = () => {
  return { info: jest.fn() };
};

const makePasswordVerifier = (
  rules = [],
  fakeLogger = makeFakeLogger()
) => {
  return new PasswordVerifier(rules, fakeLogger);
};

it("passes with zero rules", () => {
  const verifier = makePasswordVerifier([]);
  const result = verifier.verify("any input");
  expect(result).toBe(true);
});

it("fails with one failing rule", () => {
  const verifier = makePasswordVerifier([() => false]);
  const result = verifier.verify("any input");
  expect(result).toBe(false);
});
```

```python
# 좋은 예 - 팩토리 함수로 생성 로직 중앙화
def make_fake_logger():
    return FakeLogger()

def make_password_verifier(rules=None, fake_logger=None):
    if rules is None:
        rules = []
    if fake_logger is None:
        fake_logger = make_fake_logger()
    return PasswordVerifier(rules, fake_logger)

def test_passes_with_zero_rules_good():
    verifier = make_password_verifier([])
    result = verifier.verify("any input")
    assert result == True

def test_fails_with_one_failing_rule_good():
    verifier = make_password_verifier([lambda x: False])
    result = verifier.verify("any input")
    assert result == False
```

#### 2.4.2 테스트 격리 (Ch.8, pp.169-173)

**❌ 안티패턴: 테스트 간 순서 의존성**

```javascript
// 나쁜 예 - 테스트 실행 순서에 의존
describe("loginUser", () => {
  test("no user, login fails", () => {
    // ❌ 캐시가 비어있어야 함 (이전 테스트가 실행 안 됨을 가정)
    const result = app.loginUser("a", "abc");
    expect(result).toBe(false);
  });
  
  test("adds user to cache", () => {
    getUserCache().addUser({ key: "a", password: "abc" });
  });
  
  test("user exists, login succeeds", () => {
    // ❌ 이전 테스트가 실행됨을 가정
    const result = app.loginUser("a", "abc");
    expect(result).toBe(true);
  });
});
```

```python
# 나쁜 예 - 테스트 실행 순서에 의존
class TestLoginUserBad:
    def test_no_user_login_fails(self):
        # ❌ 캐시가 비어있어야 함
        result = app.login_user("a", "abc")
        assert result == False
    
    def test_adds_user_to_cache(self):
        get_user_cache().add_user({"key": "a", "password": "abc"})
    
    def test_user_exists_login_succeeds(self):
        # ❌ 이전 테스트가 실행됨을 가정
        result = app.login_user("a", "abc")
        assert result == True
```

**✅ 베스트 프랙티스: 각 테스트 독립적으로 설정**

```javascript
// 좋은 예 - 각 테스트가 필요한 것을 스스로 설정
const addDefaultUser = () =>
  getUserCache().addUser({ key: "a", password: "abc" });

describe("loginUser", () => {
  beforeEach(() => getUserCache().reset());
  
  it("user exists, login succeeds", () => {
    addDefaultUser();  // ✅ 이 테스트만의 설정
    const result = app.loginUser("a", "abc");
    expect(result).toBe(true);
  });
  
  it("user missing, login fails", () => {
    // ✅ 별도 설정 불필요 (캐시가 비어있음)
    const result = app.loginUser("a", "abc");
    expect(result).toBe(false);
  });
});
```

```python
# 좋은 예 - 각 테스트가 필요한 것을 스스로 설정
class TestLoginUserGood:
    def setup_method(self):
        get_user_cache().reset()
    
    def add_default_user(self):
        get_user_cache().add_user({"key": "a", "password": "abc"})
    
    def test_user_exists_login_succeeds(self):
        self.add_default_user()  # ✅ 이 테스트만의 설정
        result = app.login_user("a", "abc")
        assert result == True
    
    def test_user_missing_login_fails(self):
        # ✅ 별도 설정 불필요
        result = app.login_user("a", "abc")
        assert result == False
```

#### 2.4.3 과도한 명세(Overspecification) 피하기 (Ch.8, pp.177-183)

##### 안티패턴 1: 내부 메서드 검증

**❌ 나쁜 예: protected 메서드 호출 검증**

```javascript
// 나쁜 예 - 내부 구현을 테스트
test("checkFailedRules is called", () => {
  const pv = new PasswordVerifier([], fakeLogger);
  const failedMock = jest.fn(() => []);
  
  pv["findFailedRules"] = failedMock;  // ❌ 내부 메서드 모킹
  pv.verify("abc");
  
  expect(failedMock).toHaveBeenCalled();  // ❌ 내부 호출 검증
});
```

```python
# 나쁜 예 - 내부 구현을 테스트
def test_check_failed_rules_called_bad():
    pv = PasswordVerifier([], fake_logger)
    
    with patch.object(pv, '_find_failed_rules') as mock_find:
        mock_find.return_value = []
        pv.verify("abc")
        mock_find.assert_called()  # ❌ 내부 호출 검증
```

**✅ 좋은 예: 엑싯 포인트만 검증**

```javascript
// 좋은 예 - 공개 계약(반환값)을 테스트
test("verify with failing rule returns false", () => {
  const pv = new PasswordVerifier([() => false], fakeLogger);
  const result = pv.verify("abc");
  
  expect(result).toBe(false);  // ✅ 반환값(엑싯 포인트) 검증
});
```

```python
# 좋은 예 - 공개 계약(반환값)을 테스트
def test_verify_with_failing_rule():
    pv = PasswordVerifier([lambda x: False], fake_logger)
    result = pv.verify("abc")
    
    assert result == False  # ✅ 반환값(엑싯 포인트) 검증
```

##### 안티패턴 2: 순서와 구조 과도하게 검증

**❌ 나쁜 예: 모든 것을 검증**

```javascript
// 나쁜 예 - 순서, 구조, 값 모두 검증
test("overspecify order and schema", () => {
  const pv = new PasswordVerifier([input => input.includes("abc")]);
  const results = pv.verify(["a", "ab", "abc", "abcd"]);
  
  expect(results).toEqual([
    { input: "a", result: false },
    { input: "ab", result: false },
    { input: "abc", result: true },
    { input: "abcd", result: true },
  ]);
  // ❌ 순서 변경, 속성 추가 시 테스트 깨짐
});
```

```python
# 나쁜 예 - 순서, 구조, 값 모두 검증
def test_overspecify_bad():
    pv = PasswordVerifier([lambda x: "abc" in x])
    results = pv.verify(["a", "ab", "abc", "abcd"])
    
    assert results == [
        {"input": "a", "result": False},
        {"input": "ab", "result": False},
        {"input": "abc", "result": True},
        {"input": "abcd", "result": True},
    ]
    # ❌ 순서 변경, 속성 추가 시 테스트 깨짐
```

**✅ 좋은 예: 중요한 부분만 검증**

```javascript
// 좋은 예 - 순서와 스키마 무시, 로직만 검증
test("ignore order and schema", () => {
  const pv = new PasswordVerifier([input => input.includes("abc")]);
  const results = pv.verify(["a", "ab", "abc", "abcd"]);
  
  const findResultFor = (input) => 
    results.find(r => r.input === input).result;
  
  expect(results.length).toBe(4);
  expect(findResultFor("a")).toBe(false);
  expect(findResultFor("abc")).toBe(true);
  // ✅ 순서가 바뀌어도 테스트 통과
});
```

```python
# 좋은 예 - 순서와 스키마 무시, 로직만 검증
def test_ignore_order_and_schema_good():
    pv = PasswordVerifier([lambda x: "abc" in x])
    results = pv.verify(["a", "ab", "abc", "abcd"])
    
    def find_result_for(input_val):
        return next(r for r in results if r["input"] == input_val)["result"]
    
    assert len(results) == 4
    assert find_result_for("a") == False
    assert find_result_for("abc") == True
    # ✅ 순서가 바뀌어도 테스트 통과
```

##### 안티패턴 3: 문자열 완전 일치 검증

**❌ 나쁜 예: 문자열 완전 일치**

```javascript
// 나쁜 예 - 문자열을 정확히 일치시킴
test("over specify string", () => {
  const pv = new PasswordVerifier([input => input.includes("abc")]);
  pv.verify(["a", "ab", "abc", "abcd"]);
  const msg = pv.getMsg();
  
  expect(msg).toBe("you have 2 failed rules.");
  // ❌ 마침표, 대소문자, 표현 변경 시 테스트 깨짐
});
```

```python
# 나쁜 예 - 문자열을 정확히 일치시킴
def test_over_specify_string_bad():
    pv = PasswordVerifier([lambda x: "abc" in x])
    pv.verify(["a", "ab", "abc", "abcd"])
    msg = pv.get_msg()
    
    assert msg == "you have 2 failed rules."
    # ❌ 마침표, 대소문자, 표현 변경 시 테스트 깨짐
```

**✅ 좋은 예: 핵심 내용만 검증**

```javascript
// 좋은 예 - 핵심 내용만 포함되었는지 확인
test("more future proof string checking", () => {
  const pv = new PasswordVerifier([input => input.includes("abc")]);
  pv.verify(["a", "ab", "abc", "abcd"]);
  const msg = pv.getMsg();
  
  expect(msg).toMatch(/2 failed/);
  // ✅ 표현이 조금 바뀌어도 테스트 통과
});
```

```python
# 좋은 예 - 핵심 내용만 포함되었는지 확인
def test_more_future_proof_string_good():
    pv = PasswordVerifier([lambda x: "abc" in x])
    pv.verify(["a", "ab", "abc", "abcd"])
    msg = pv.get_msg()
    
    assert "2 failed" in msg
    # ✅ 표현이 조금 바뀌어도 테스트 통과
```

---

### 2.5 가독성 향상 (Ch.9)

#### 2.5.1 테스트 네이밍 (Ch.9, pp.188-189)

**3가지 필수 정보:** (Ch.9, p.188)
1. **엔트리 포인트** - 무엇을 테스트하는가?
2. **시나리오** - 어떤 상황에서?
3. **기대 동작** - 무엇을 해야 하는가?

**JavaScript 예제:**
```javascript
// ✅ 좋은 예 - 모든 정보 포함
test('verifyPassword, with a failing rule, returns error based on rule.reason', () => {
  // 엔트리 포인트: verifyPassword
  // 시나리오: with a failing rule
  // 기대 동작: returns error based on rule.reason
});

// ✅ 또는 중첩 describe 사용
describe('verifyPassword', () => {
  describe('with a failing rule', () => {
    it('returns error based on the rule.reason', () => {
      // ...
    });
  });
});
```

**Python 버전:**
```python
# ✅ 좋은 예 - 중첩 클래스로 구조화
class TestVerifyPassword:
    class TestWithFailingRule:
        def test_returns_error_based_on_rule_reason(self):
            # 엔트리 포인트: VerifyPassword
            # 시나리오: WithFailingRule
            # 기대 동작: returns_error_based_on_rule_reason
            pass

# ✅ 또는 함수 이름으로 모든 정보 표현
def test_verify_password_with_failing_rule_returns_error_based_on_rule_reason():
    # 엔트리 포인트: verify_password
    # 시나리오: with_failing_rule
    # 기대 동작: returns_error_based_on_rule_reason
    pass
```

**❌ 나쁜 예 - 정보 누락:** (Ch.9, p.189)
```javascript
// ❌ 엔트리 포인트 누락
test('failing rule, returns error', () => { ... });

// ❌ 시나리오 누락
test('verifyPassword, returns error', () => { ... });

// ❌ 기대 동작 누락
test('verifyPassword, with failing rule', () => { ... });
```

```python
# ❌ 엔트리 포인트 누락
def test_failing_rule_returns_error():
    pass

# ❌ 시나리오 누락
def test_verify_password_returns_error():
    pass

# ❌ 기대 동작 누락
def test_verify_password_with_failing_rule():
    pass
```

#### 2.5.2 매직 값 제거 (Ch.9, pp.189-190)

**❌ 안티패턴: 매직 값 사용**

```javascript
// 나쁜 예 - 의미를 알 수 없는 값들
test('on weekends, throws exceptions', () => {
  expect(() => verifyPassword('jhGGu78!', [], 0))
    .toThrowError("It's the weekend!");
  // 'jhGGu78!'는 무엇? []는? 0은?
});
```

```python
# 나쁜 예 - 의미를 알 수 없는 값들
def test_weekend_throws_bad():
    with pytest.raises(Exception, match="It's the weekend!"):
        verify_password('jhGGu78!', [], 0)
    # 'jhGGu78!'는 무엇? []는? 0은?
```

**✅ 베스트 프랙티스: 의미 있는 변수명 사용**

```javascript
// 좋은 예 - 각 값의 의미가 명확
test("on weekends, throws exceptions", () => {
  const SUNDAY = 0;
  const NO_RULES = [];
  const ANY_PASSWORD = "anything";
  
  expect(() => verifyPassword(ANY_PASSWORD, NO_RULES, SUNDAY))
    .toThrowError("It's the weekend!");
});
```

```python
# 좋은 예 - 각 값의 의미가 명확
def test_weekend_throws_good():
    SUNDAY = 0
    NO_RULES = []
    ANY_PASSWORD = "anything"
    
    with pytest.raises(Exception, match="It's the weekend!"):
        verify_password(ANY_PASSWORD, NO_RULES, SUNDAY)
```

#### 2.5.3 액션과 어설션 분리 (Ch.9, pp.190-191)

**❌ 안티패턴: 한 줄에 모두 작성**

```javascript
// 나쁜 예 - 읽기 어렵고 디버깅 어려움
expect(verifier.verify("any value")[0]).toContain("fake reason");
```

```python
# 나쁜 예 - 읽기 어렵고 디버깅 어려움
assert "fake reason" in verifier.verify("any value")[0]
```

**✅ 베스트 프랙티스: 액션과 어설션 분리**

```javascript
// 좋은 예 - 명확하고 디버깅 용이
const result = verifier.verify("any value");
expect(result[0]).toContain("fake reason");
```

```python
# 좋은 예 - 명확하고 디버깅 용이
result = verifier.verify("any value")
assert "fake reason" in result[0]
```

#### 2.5.4 Setup 함수 피하기 (Ch.9, pp.191-193)

**❌ 안티패턴: beforeEach에서 목 설정**

```javascript
// 나쁜 예 - 테스트 맨 위로 스크롤해야 mockLog의 정체를 알 수 있음
describe("password verifier", () => {
  let mockLog;
  
  beforeEach(() => {
    mockLog = Substitute.for<IComplicatedLogger>();
  });
  
  test("verify calls logger with PASS", () => {
    const verifier = new PasswordVerifier([], mockLog);
    verifier.verify("anything");
    mockLog.received().info(
      Arg.is(x => x.includes("PASSED")),
      "verify"
    );
  });
});
```

```python
# 나쁜 예 - 테스트 맨 위로 스크롤해야 mock_log의 정체를 알 수 있음
class TestPasswordVerifier:
    def setup_method(self):
        self.mock_log = Mock()
    
    def test_verify_calls_logger_with_pass(self):
        verifier = PasswordVerifier([], self.mock_log)
        verifier.verify("anything")
        # mock_log이 어디서 왔는지 찾아야 함
```

**✅ 베스트 프랙티스: 테스트 내부 또는 헬퍼 함수**

```javascript
// 좋은 예 1 - 테스트 내부에서 직접 생성
test("verify calls logger with PASS", () => {
  const mockLog = Substitute.for<IComplicatedLogger>();
  const verifier = new PasswordVerifier([], mockLog);
  verifier.verify("anything");
  mockLog.received().info(
    Arg.is(x => x.includes("PASSED")),
    "verify"
  );
});

// 좋은 예 2 - 헬퍼 함수 사용
const makeMockLogger = () => Substitute.for<IComplicatedLogger>();

test("verify calls logger with PASS", () => {
  const mockLog = makeMockLogger();
  const verifier = new PasswordVerifier([], mockLog);
  verifier.verify("anything");
  mockLog.received().info(
    Arg.is(x => x.includes("PASSED")),
    "verify"
  );
});
```

```python
# 좋은 예 1 - 테스트 내부에서 직접 생성
def test_verify_calls_logger_with_pass_good():
    mock_log = Mock()
    verifier = PasswordVerifier([], mock_log)
    verifier.verify("anything")
    mock_log.info.assert_called()

# 좋은 예 2 - 헬퍼 함수 사용
def make_mock_logger():
    return Mock()

def test_verify_calls_logger_with_pass_with_helper():
    mock_log = make_mock_logger()
    verifier = PasswordVerifier([], mock_log)
    verifier.verify("anything")
    mock_log.info.assert_called()
```

---

## 3. 단위 테스트 체크리스트

### 3.1 작성 전 체크리스트 (Ch.1, pp.16-17)

다음 질문에 모두 "예"라고 답할 수 있어야 함:

**실행 및 결과:**
- [ ] 몇 주/몇 달 전에 작성한 테스트를 실행하고 결과를 얻을 수 있는가?
- [ ] 팀의 누구나 내가 작성한 테스트를 실행하고 결과를 얻을 수 있는가?
- [ ] 모든 테스트를 몇 분 이내에 실행할 수 있는가?
- [ ] 버튼 하나로 모든 테스트를 실행할 수 있는가?

**작성 및 격리:**
- [ ] 기본적인 테스트를 몇 분 이내에 작성할 수 있는가?
- [ ] 다른 팀의 코드에 버그가 있어도 내 테스트는 통과하는가?
- [ ] 다른 머신이나 환경에서도 같은 결과를 보여주는가?
- [ ] 데이터베이스, 네트워크, 배포 없이도 테스트가 작동하는가?
- [ ] 한 테스트를 삭제/이동/변경해도 다른 테스트는 영향받지 않는가?

### 3.2 신뢰성 체크리스트 (Ch.7, pp.150-164)

#### 테스트 실패 시 확인사항:

**원인 파악:**
- [ ] 실패 원인이 진짜 버그인가? (Ch.7, p.151)
- [ ] 테스트 자체에 버그가 있는가? (Ch.7, pp.151-152)
  - [ ] 잘못된 것을 어설션하고 있지 않은가?
  - [ ] 엔트리 포인트에 잘못된 값을 주입하지 않았는가?
  - [ ] 엔트리 포인트를 잘못 호출하지 않았는가?
- [ ] 기능 변경으로 테스트가 구식이 되었는가? (Ch.7, p.152)
- [ ] 다른 테스트와 충돌하는가? (Ch.7, pp.152-153)
- [ ] 테스트가 플래키(flaky)한가? (Ch.7, pp.153, 161-164)

#### 테스트 통과 시 확인사항:

**기본 검증:**
- [ ] 테스트에 어설션이 있는가? (Ch.7, p.157)
- [ ] 테스트를 이해할 수 있는가? (Ch.7, p.157)
- [ ] 플래키한 통합 테스트와 섞여있지 않은가? (Ch.7, p.158)
- [ ] 여러 관심사를 검증하고 있지 않은가? (Ch.7, pp.158-160)
- [ ] 동적 값(시간, 랜덤 등)을 사용하지 않는가? (Ch.7, pp.160-161)

**로직 검증:**
- [ ] if/else, switch 문이 없는가? (Ch.7, p.153)
- [ ] foreach, for, while 루프가 없는가? (Ch.7, p.153)
- [ ] 문자열 연결(+)이 없는가? (Ch.7, p.153)
- [ ] try/catch가 없는가? (Ch.7, p.153)
- [ ] 동적 기대값을 생성하지 않는가? (Ch.7, pp.153-155)

### 3.3 유지보수성 체크리스트 (Ch.8)

**API 변경 대응:**
- [ ] 팩토리 함수를 사용하는가? (Ch.8, pp.168-169)
- [ ] 생성자 변경 시 한 곳만 수정하면 되는가?

**테스트 격리:**
- [ ] 각 테스트가 독립적으로 실행되는가? (Ch.8, pp.169-173)
- [ ] beforeEach/setup_method로 공유 리소스를 리셋하는가?
- [ ] 테스트 실행 순서에 의존하지 않는가?

**중복 제거:**
- [ ] DRY 원칙을 따르는가? (Ch.8, p.175)
- [ ] 헬퍼 함수를 사용하는가?
- [ ] 파라미터화된 테스트를 고려했는가? (Ch.8, pp.176-177)

**명세 수준:**
- [ ] private/protected 메서드를 테스트하지 않는가? (Ch.8, pp.173-175)
- [ ] 내부 동작이 아닌 공개 계약을 테스트하는가? (Ch.8, pp.177-179)
- [ ] 순서나 구조를 과도하게 검증하지 않는가? (Ch.8, pp.179-181)
- [ ] 문자열 완전 일치 대신 포함 여부를 확인하는가? (Ch.8, pp.181-183)

### 3.4 가독성 체크리스트 (Ch.9)

**네이밍:**
- [ ] 테스트 이름에 엔트리 포인트가 포함되어 있는가? (Ch.9, p.188)
- [ ] 테스트 이름에 시나리오가 포함되어 있는가? (Ch.9, p.188)
- [ ] 테스트 이름에 기대 동작이 포함되어 있는가? (Ch.9, p.188)

**매직 값:**
- [ ] 의미 있는 변수명을 사용하는가? (Ch.9, pp.189-190)
- [ ] 숫자/문자열 리터럴을 직접 사용하지 않는가?

**구조:**
- [ ] 액션과 어설션이 분리되어 있는가? (Ch.9, pp.190-191)
- [ ] Setup 메서드 대신 헬퍼 함수를 사용하는가? (Ch.9, pp.191-193)
- [ ] 목(mock) 초기화가 테스트 내부에 있는가? (Ch.9, pp.191-192)

---

## 4. 테스트 실패 시 대응 프로세스 (Ch.7, pp.151-152)

```
1. 테스트 실패 발견
   ↓
2. 프로덕션 코드 디버깅
   ↓
3. 프로덕션 코드에 버그 없음?
   ↓ (예)
4. 테스트 코드 디버깅
   ↓
5. 테스트 버그 발견 및 수정
   ↓
6. 테스트 실행 → 통과 확인
   ↓
7. 프로덕션 코드에 명백한 버그 삽입
   ↓
8. 테스트 실행 → 실패 확인
   ↓
9. 프로덕션 버그 제거
   ↓
10. 테스트 실행 → 통과 확인
    ↓
11. 커밋
```

**핵심 원칙:**
- 테스트가 통과할 때와 실패할 때 모두 확인해야 함
- 이를 통해 테스트가 올바르게 동작하는지 검증
- TDD(Test-Driven Development)를 사용하면 이 과정이 자동으로 이루어짐

---

## 5. 요약: 좋은 테스트의 3가지 기둥

### 5.1 신뢰성 (Trustworthiness) (Ch.7, pp.149-164)
- 테스트 결과를 신뢰할 수 있어야 함
- 실패 시: 진짜 버그를 찾았다고 확신
- 통과 시: 수동 테스트 불필요

### 5.2 유지보수성 (Maintainability) (Ch.8, pp.165-187)
- 변경이 쉬워야 함
- 프로덕션 코드 변경 시 최소한의 테스트 수정
- 테스트 간 독립성 유지

### 5.3 가독성 (Readability) (Ch.9, pp.187-194)
- 의도가 명확해야 함
- 누구나 쉽게 이해 가능
- 실패 시 문제를 빠르게 파악

---

## 참고 문헌

이 가이드는 다음 책을 바탕으로 작성되었습니다:

**The Art of Unit Testing, 3rd Edition** by Roy Osherove (Manning, 2024)
- Chapter 1: The basics of unit testing (pp.3-28)
- Chapter 7: Trustworthy tests (pp.149-165)
- Chapter 8: Maintainability (pp.165-187)
- Chapter 9: Readability (pp.187-194)