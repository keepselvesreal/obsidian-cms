---
version: 1.0
note: A Philosophy of Software Design - Chapter 2 Summary
creator: Haiku 4.5
created_time: 25-12-08 12:17
---

## 압축 내용

복잡성은 소프트웨어 시스템의 구조로 인해 이해와 수정을 어렵게 만드는 모든 것으로, 의존성(dependencies)과 불명확성(obscurity)이라는 두 가지 원인으로부터 발생하며, 변경 증폭(change amplification), 인지 부하(cognitive load), 미지의 미지(unknown unknowns)라는 세 가지 증상으로 나타난다. [2.1-2.3, p.19-25]

---

## 핵심 내용

### 복잡성의 정의 (Complexity Defined)
복잡성은 소프트웨어 시스템을 이해하고 수정하기 어렵게 만드는 구조적 특성이다. [2.1, p.19] 이는 코드 라인 수와 무관하며, 개발자들이 경험하는 상황에 따라 상대적으로 결정된다. 같은 기능이라도 쉽게 작업할 수 있으면 단순하고, 어려우면 복잡한 것이다. [2.1, p.20]

### 복잡성의 세 가지 증상 (Symptoms of Complexity)
**변경 증폭**: 한 곳의 작은 변경이 여러 곳의 코드 수정을 요구하는 현상이다. [2.2, p.21] **인지 부하**: 작업을 완료하기 위해 개발자가 알아야 할 정보의 양이 많아지는 것이다. [2.2, p.21] **미지의 미지**: 어떤 코드를 수정해야 하는지, 무엇을 알아야 하는지 명확하지 않은 상황이 가장 심각한 증상이다. [2.2, p.23]

### 복잡성의 두 가지 원인 (Causes of Complexity)
**의존성**: 한 코드 조각이 다른 코드와 관련되어 있어서 독립적으로 수정할 수 없는 상태이다. [2.3, p.24] **불명확성**: 중요한 정보가 명확하지 않거나 드러나지 않는 상태이다. [2.3, p.25] 이 두 원인은 세 가지 증상(변경 증폭, 인지 부하, 미지의 미지)을 직접 유발한다. [2.3, p.25]

### 점진적 복잡성 (Complexity is Incremental)
복잡성은 한 번에 발생하지 않고 수백 개의 작은 의존성과 불명확성들이 시간에 따라 축적되어 발생한다. [2.4, p.25-26] 각 변경에서 조금씩 더하는 복잡성은 문제없어 보이지만, 누적되면 통제 불가능해진다. [2.4, p.26]

---

## 상세 내용

### 목차
1. [복잡성 정의 및 개념](#1-복잡성의-정의-및-개념)
2. [복잡성의 세 가지 증상](#2-복잡성의-세-가지-증상)
   - [변경 증폭](#21-변경-증폭-change-amplification)
   - [인지 부하](#22-인지-부하-cognitive-load)
   - [미지의 미지](#23-미지의-미지-unknown-unknowns)
3. [복잡성의 두 가지 원인](#3-복잡성의-두-가지-원인)
   - [의존성](#31-의존성-dependencies)
   - [불명확성](#32-불명확성-obscurity)
4. [점진적 복잡성의 특성](#4-점진적-복잡성의-특성)
5. [설계 철학으로의 시사점](#5-설계-철학으로의-시사점)

---

### 1. 복잡성의 정의 및 개념

복잡성이란 소프트웨어 시스템의 구조로 인해 그 시스템을 이해하고 수정하기 어렵게 만드는 모든 것이다. [2.1, p.19-20] 예를 들어, 코드가 어떻게 작동하는지 이해하기 어렵거나, 작은 개선사항을 구현하려면 많은 노력이 필요하거나, 어떤 부분을 수정해야 하는지 불명확하거나, 한 버그를 고쳐도 다른 버그가 생기는 상황 모두가 복잡성이다. [2.1, p.20]

복잡성은 **개발자의 경험**에 기반한다. [2.1, p.20] 대규모 시스템이 실제로는 작업하기 쉽다면 복잡하지 않은 것이고, 작은 시스템이라도 작업하기 어렵다면 복잡한 것이다. [2.1, p.20-21] 또한 복잡성은 가장 자주 다루는 부분의 복잡도에 의해 결정된다. [2.1, p.21] 아무리 복잡한 부분이 있어도 거의 건드릴 일이 없다면 전체 시스템의 복잡성에 큰 영향을 주지 않는다.

복잡성은 **쓰는 사람보다 읽는 사람에게 더 명확하다.** [2.1, p.21] 자신은 단순하게 느꼈던 코드가 다른 개발자에게 복잡하게 느껴진다면, 그것이 복잡한 것이다. [2.1, p.21] 개발자의 역할은 자신이 쉽게 작업할 수 있는 코드뿐만 아니라 다른 사람도 쉽게 작업할 수 있는 코드를 작성하는 것이다. [2.1, p.21]

---

### 2. 복잡성의 세 가지 증상

#### 2.1 변경 증폭 (Change Amplification)

변경 증폭은 겉보기에 간단한 변경이 코드의 여러 곳을 수정하게 하는 현상이다. [2.2, p.21] 예를 들어, 초기 웹 사이트 설계에서는 배너 색상을 모든 페이지에 개별적으로 지정했는데, 색을 변경하려면 모든 페이지를 수정해야 했다. [2.2, p.21] 현대 웹 사이트는 색상을 중앙에서 한 곳에 정의하고 모든 페이지가 그 값을 참조하므로, 색상 변경은 한 곳만 수정하면 된다. [2.2, p.21]

좋은 설계의 목표 중 하나는 각 설계 결정이 영향을 주는 코드의 양을 줄이는 것이다. [2.2, p.21-22]

#### 2.2 인지 부하 (Cognitive Load)

인지 부하는 작업을 완료하기 위해 개발자가 알아야 할 정보의 양을 나타낸다. [2.2, p.22] 인지 부하가 높으면 개발자가 필요한 정보를 학습하는 데 더 많은 시간을 소비해야 하고, 중요한 것을 놓칠 위험도 커진다. [2.2, p.22]

예를 들어, C의 메모리 할당 함수가 포인터를 반환하고 호출자가 메모리를 해제할 책임을 진다면, 이 함수를 사용하는 모든 개발자가 메모리 해제를 기억해야 한다. [2.2, p.22] 할당과 해제를 같은 모듈이 담당하도록 재구성하면 인지 부하가 줄어든다. [2.2, p.22]

중요한 점은 **라인 수와 복잡성의 관계는 없다는 것이다.** [2.2, p.22] 몇 줄의 코드를 사용해 애플리케이션을 작성할 수 있는 프레임워크는 있지만, 그 몇 줄이 무엇인지 파악하는 것이 극도로 어려울 수 있다. [2.2, p.22] 더 많은 줄의 코드가 필요한 접근 방식이 인지 부하를 줄이므로 더 단순할 수 있다. [2.2, p.22]

#### 2.3 미지의 미지 (Unknown Unknowns)

미지의 미지는 어떤 코드를 수정해야 하는지, 어떤 정보를 알아야 하는지 명확하지 않은 상황이다. [2.2, p.23] 이는 세 가지 증상 중 **가장 심각하다.** [2.2, p.23]

예를 들어, 웹 사이트에서 배너 배경색은 중앙 변수로 관리되지만, 일부 페이지에서는 강조를 위해 더 어두운 색을 명시적으로 지정한다. [2.2, p.22-23] 배경색을 변경하면 강조색도 변경해야 하는데, 개발자는 이를 인식하지 못할 수 있다. [2.2, p.23] 또한 어느 페이지에서 강조색을 사용하는지 명확하지 않아 모든 페이지를 검색해야 할 수도 있다. [2.2, p.23]

미지의 미지는 알아야 할 것이 있지만 그것이 무엇인지 알 수 없는 상태이다. [2.2, p.23] 변경 후 버그가 나타날 때까지 문제를 알 수 없다. [2.2, p.23] 변경 증폭은 성가시지만, 어떤 코드를 수정해야 하는지 명확하면 변경을 완료한 후 시스템이 작동한다. [2.2, p.23] 인지 부하가 높으면 변경 비용이 증가하지만, 읽을 정보가 명확하면 변경이 여전히 올바를 가능성이 높다. [2.2, p.23] 그러나 미지의 미지는 무엇을 할지, 해결책이 작동할지도 불명확하다. [2.2, p.23-24]

좋은 설계의 가장 중요한 목표 중 하나는 시스템을 **명확하게(obvious)** 만드는 것이다. [2.2, p.24] 명확한 시스템에서는 개발자가 기존 코드가 어떻게 작동하는지, 변경을 위해 무엇이 필요한지 빠르게 이해할 수 있다. [2.2, p.24] 명확한 시스템에서는 개발자가 깊이 생각하지 않고도 추측할 수 있고 그 추측이 맞을 것이라 확신할 수 있다. [2.2, p.24]

---

### 3. 복잡성의 두 가지 원인

#### 3.1 의존성 (Dependencies)

의존성은 한 코드 조각이 다른 코드와 관련되어 있어서 독립적으로 이해하고 수정할 수 없는 상태이다. [2.3, p.24] 웹 사이트 예시에서 배경색이 여러 페이지에 명시적으로 지정되면, 모든 페이지가 배경색에 의존한다. [2.3, p.24] 네트워크 프로토콜에서 송신자와 수신자의 코드는 프로토콜을 따라야 하므로, 송신자 코드 변경은 수신자 변경을 필요로 한다. [2.3, p.24-25] 메서드의 서명(signature)은 그 메서드의 구현과 호출 코드 사이에 의존성을 만든다. [2.3, p.25]

의존성은 소프트웨어의 근본적인 부분이며 완전히 제거할 수 없다. [2.3, p.25] 실제로 설계 과정에서 의도적으로 의존성을 도입한다. [2.3, p.25] 새 클래스를 작성할 때마다 그 클래스의 API 주변에 의존성을 만든다. [2.3, p.25] 그러나 소프트웨어 설계의 목표 중 하나는 의존성의 수를 줄이고, 남은 의존성을 가능한 한 단순하고 명확하게 만드는 것이다. [2.3, p.25]

배경색 예시에서 초기 설계는 모든 페이지를 서로 의존하게 했다. [2.3, p.25] 새 설계는 배경색을 중앙에 지정하고 개별 페이지가 그 색을 검색하는 API를 제공함으로써 페이지 간 의존성을 제거했다. [2.3, p.25-26] 대신 배경색 검색 API에 대한 의존성을 만들었는데, 이는 더 명확하다. [2.3, p.26] 각 페이지가 배경색에 의존함이 명확하고, 개발자는 변수 이름을 검색해 모든 사용 위치를 쉽게 찾을 수 있다. [2.3, p.26] 컴파일러도 API 의존성을 관리하는 데 도움이 된다. [2.3, p.26]

#### 3.2 불명확성 (Obscurity)

불명확성은 중요한 정보가 명확하지 않은 상태이다. [2.3, p.25] 예를 들어, 변수 이름이 너무 일반적이어서 정보를 주지 못한다. [2.3, p.25] 또는 변수의 단위를 문서화하지 않으면 코드에서 사용 위치를 찾아야만 알 수 있다. [2.3, p.25]

불명확성은 종종 의존성과 연결되어 있는데, 의존성이 존재한다는 사실 자체가 명확하지 않을 수 있다. [2.3, p.25] 예를 들어, 새로운 에러 상태가 추가되면 상태별 문자열 메시지를 담은 테이블에 항목을 추가해야 하는데, 상태 선언을 보는 프로그래머는 메시지 테이블의 존재를 알지 못할 수 있다. [2.3, p.25] 불일치도 불명확성의 주요 원인이다. [2.3, p.25] 같은 변수 이름을 두 가지 다른 목적으로 사용하면, 개발자는 특정 변수가 어느 목적인지 알 수 없다. [2.3, p.25]

많은 경우 불명확성은 부족한 문서화로 인해 발생하지만, 설계 문제이기도 하다. [2.3, p.25] 시스템이 명확하고 깔끔한 설계를 가지면 문서화가 덜 필요하다. [2.3, p.25] 광범위한 문서화가 필요하다는 것은 설계가 완벽하지 않다는 신호이다. [2.3, p.25] 불명확성을 줄이는 최선의 방법은 시스템 설계를 단순화하는 것이다. [2.3, p.25]

#### 3.3 의존성과 불명확성의 관계

의존성과 불명확성이 함께 세 가지 복잡성 증상을 만든다. [2.3, p.25-26] 의존성은 변경 증폭과 높은 인지 부하로 이어진다. [2.3, p.26] 불명확성은 미지의 미지를 만들고 인지 부하를 증가시킨다. [2.3, p.26] 의존성과 불명확성을 최소화하는 설계 기법을 찾을 수 있다면, 소프트웨어의 복잡성을 줄일 수 있다. [2.3, p.26]

---

### 4. 점진적 복잡성의 특성

복잡성은 하나의 거대한 재앙으로 인해 발생하지 않고, **수백 개 또는 수천 개의 작은 청크에서 축적된다.** [2.4, p.26] 하나의 의존성이나 불명확성은 개별적으로는 소프트웨어 시스템의 유지보수성에 큰 영향을 주지 못한다. [2.4, p.26] 복잡성은 시간이 지나면서 수백 또는 수천 개의 작은 의존성과 불명확성이 축적되어 발생한다. [2.4, p.26] 결국 시스템에 대한 모든 가능한 변경이 여러 문제에 영향을 받는다. [2.4, p.26]

**복잡성의 점진적 특성은 그것을 통제하기 어렵게 만든다.** [2.4, p.26] 현재 변경이 도입하는 작은 복잡성이 큰 문제 아닌 것처럼 보이는 것은 쉽다. [2.4, p.26] 그러나 모든 개발자가 모든 변경에서 이 접근 방식을 취한다면, 복잡성은 빠르게 축적된다. [2.4, p.26] 복잡성이 축적되면 제거하기 어렵다. [2.4, p.26-27] 하나의 의존성이나 불명확성을 고치는 것만으로는 큰 차이를 만들지 못하기 때문이다. [2.4, p.27]

복잡성의 증가를 늦추려면 "영점 허용(zero tolerance)" 철학을 채택해야 한다. [2.4, p.27] 이는 각 변경에서 추가하는 작은 복잡성도 피하려고 노력해야 한다는 의미이다.

---

### 5. 설계 철학으로의 시사점

복잡성은 의존성과 불명확성의 축적으로부터 발생한다. [2.5, p.26] 복잡성이 증가하면 변경 증폭, 높은 인지 부하, 미지의 미지로 이어진다. [2.5, p.26] 결과적으로 각 새로운 기능을 구현하는 데 더 많은 코드 수정이 필요하다. [2.5, p.26-27] 또한 개발자는 변경을 안전하게 수행하기 위해 충분한 정보를 수집하는 데 더 많은 시간을 소비하고, 최악의 경우 필요한 모든 정보를 찾을 수 없다. [2.5, p.27] 결국 복잡성은 기존 코드베이스를 수정하기 어렵고 위험하게 만든다. [2.5, p.27]

따라서 복잡성을 최소화하는 것이 좋은 소프트웨어 설계의 핵심이다.
