---
version: 1.0
note: A Philosophy of Software Design - Chapter 5 Summary
creator: Haiku 4.5
created_time: 25-12-08 12:19
---

## 압축 내용

**정보 은닉(information hiding)**은 깊은 모듈을 만드는 가장 중요한 기법이다. [5.1, p.44] 각 모듈은 몇 가지 설계 결정을 캡슐화하고, 그 지식을 모듈의 구현에 임베드하되 인터페이스에는 노출하지 않는다. [5.1, p.42-44] 반대로 **정보 유출(information leakage)**은 설계의 결정이 여러 모듈에 반영되어 모듈 간에 의존성을 만드는 가장 중요한 위험 신호(red flag)이다. [5.2, p.45-48]

---

## 핵심 내용

### 정보 은닉의 정의와 기능
정보 은닉은 모듈이 설계 결정을 나타내는 몇 가지 지식을 캡슐화하는 기법이다. [5.1, p.41-44] 숨겨진 정보는 구현에 임베드되지만 인터페이스에는 나타나지 않아 다른 모듈에는 보이지 않는다. [5.1, p.42-44] B-트리 저장/접근 방식, TCP 프로토콜 구현, JSON 문서 파싱 등이 숨겨져야 할 정보의 예이다. [5.1, p.47-56]

정보 은닉은 두 가지 방식으로 복잡성을 줄인다. [5.1, p.36-48] 첫째, 모듈의 인터페이스를 단순화한다. [5.1, p.37-39] 인터페이스는 더 단순하고 추상적인 기능 관점을 반영하고, 세부 사항은 숨긴다. [5.1, p.37-39] 둘째, 시스템을 진화시키기 쉽게 만든다. [5.1, p.41-48] 정보가 숨겨져 있으면, 그 정보에 대한 의존성이 모듈 외부에 없으므로 관련 설계 변경이 그 모듈에만 영향을 미친다. [5.1, p.41-48]

### 정보 유출의 정의와 문제
정보 유출은 설계 결정이 여러 모듈에 반영되는 것이다. [5.2, p.45-47] 이는 모듈 간에 의존성을 만든다. [5.2, p.45-47] 그 설계 결정을 변경하려면 관련된 모든 모듈을 변경해야 한다. [5.2, p.45-47]

정보 유출은 인터페이스를 통해 직접 발생할 수도 있고, "뒷문 유출"처럼 숨겨져 발생할 수도 있다. [5.2, p.48-57] 예를 들어, 두 클래스가 모두 특정 파일 형식을 이해한다면(파일을 읽거나 쓰기 위해), 형식이 변경되면 두 클래스 모두 수정해야 한다. [5.2, p.50-57] 이는 인터페이스에 나타나지 않지만 여전히 의존성을 만드는 정보 유출이다. [5.2, p.50-57]

정보 유출은 설계의 가장 중요한 위험 신호 중 하나이다. [5.2, p.57-58] 좋은 소프트웨어 설계자가 배우는 가장 좋은 기술 중 하나는 정보 유출에 대한 높은 감각이다. [5.2, p.58-59]

### 시간적 분해(Temporal Decomposition)
정보 유출의 일반적인 원인은 **시간적 분해**이다. [5.3, p.42-48] 시간적 분해는 시스템의 구조가 작업이 발생하는 시간 순서에 대응되는 설계 스타일이다. [5.3, p.42-48] 파일을 읽고 수정한 다음 다시 쓰는 애플리케이션을 생각해보자. [5.3, p.44-48] 시간적 분해에서는 이를 세 개의 클래스로 나눌 것이다: 읽는 클래스, 수정하는 클래스, 쓰는 클래스. [5.3, p.44-48] 그러나 파일 읽기 및 쓰기 단계 모두에서 파일 형식에 대한 지식이 필요하므로 정보 유출이 발생한다. [5.3, p.49-57]

해결책은 파일 읽기 및 쓰기를 위한 핵심 메커니즘을 단일 클래스에 결합하는 것이다. [5.3, p.50-52] 이 클래스는 애플리케이션의 읽기 및 쓰기 단계 모두에서 사용된다. [5.3, p.50-52]

모듈을 설계할 때는 **작업이 발생하는 순서가 아닌, 각 작업을 수행하는 데 필요한 지식에 집중해야 한다.** [5.3, p.61-63]

---

## 상세 내용

### 목차
1. [정보 은닉의 개념과 이점](#1-정보-은닉의-개념과-이점)
2. [정보 유출의 정의와 유형](#2-정보-유출의-정의와-유형)
3. [시간적 분해와 정보 유출](#3-시간적-분해와-정보-유출)
4. [HTTP 서버 구현: 정보 은닉 사례 분석](#4-http-서버-구현-정보-은닉-사례-분석)
5. [클래스 내 정보 은닉](#5-클래스-내-정보-은닉)
6. [정보 은닉의 한계 인식](#6-정보-은닉의-한계-인식)
7. [정보 은닉과 깊은 모듈의 관계](#7-정보-은닉과-깊은-모듈의-관계)

---

### 1. 정보 은닉의 개념과 이점

**정보 은닉**은 David Parnas에 의해 처음 기술된 기법으로, 가장 중요한 복잡성 관리 방법 중 하나이다. [5.1, p.41-44] 기본 아이디어는 **각 모듈이 몇 가지 지식(설계 결정)을 캡슐화하고, 그것을 모듈 구현에만 포함시키되 인터페이스에는 노출하지 않는 것**이다. [5.1, p.42-44]

숨겨져야 할 정보는 일반적으로 어떤 메커니즘을 구현하는 방법에 관한 세부 사항이다. [5.1, p.47-49] 다음이 숨겨질 수 있는 정보의 예이다: [5.1, p.49-56]

- B-트리에 정보를 저장하고 효율적으로 접근하는 방법
- 파일 내 각 논리적 블록에 대응되는 실제 디스크 블록을 식별하는 방법
- TCP 네트워크 프로토콜 구현 방법
- 멀티코어 프로세서에서 스레드 스케줄링 방법
- JSON 문서 파싱 방법

숨겨진 정보는 데이터 구조와 알고리즘뿐만 아니라, 페이지 크기 같은 낮은 수준의 세부 사항과 "대부분의 파일은 작다"는 가정처럼 더 추상적인 높은 수준의 개념도 포함할 수 있다. [5.1, p.57-60]

#### 정보 은닉의 두 가지 이점

**복잡성 감소**: [5.1, p.36-48]
- **인터페이스 단순화**: 정보 은닉은 모듈 인터페이스를 단순화한다. 인터페이스는 더 단순하고 추상적인 기능 관점을 반영하고, 세부 사항은 숨긴다. [5.1, p.36-39] 예를 들어, B-트리 클래스 사용자는 트리의 이상적인 fanout이나 균형을 유지하는 방법에 대해 걱정할 필요가 없다. [5.1, p.39-41]
- **시스템 진화 용이**: 정보가 숨겨져 있으면, 그 정보에 대한 의존성이 모듈 외부에 없다. [5.1, p.41-44] 따라서 그 정보와 관련된 설계 변경은 모듈에만 영향을 미친다. [5.1, p.41-44] 예를 들어, TCP 프로토콜이 혼잡 제어 메커니즘을 도입하도록 변경되면, 프로토콜 구현을 수정해야 하지만 TCP를 사용해 데이터를 보내고 받는 높은 수준의 코드는 변경할 필요가 없다. [5.1, p.45-48]

### 2. 정보 유출의 정의와 유형

**정보 유출**은 정보 은닉의 반대이다. [5.2, p.44-47] 정보 유출은 설계 결정이 여러 모듈에 반영되는 것이다. [5.2, p.45-47] 이는 모듈 간에 의존성을 만든다. [5.2, p.45-47] 그 설계 결정을 변경하려면 관련된 모든 모듈을 변경해야 한다. [5.2, p.45-47]

#### 인터페이스를 통한 유출
정보가 모듈의 인터페이스에 반영되면, 그 정보는 정의상 유출된 것이다. [5.2, p.48-51] 따라서 단순한 인터페이스는 더 나은 정보 은닉과 연관된다. [5.2, p.48-51]

#### 뒷문 유출 (Back-door Leakage)
정보는 모듈의 인터페이스에 나타나지 않아도 유출될 수 있다. [5.2, p.50-57] 예를 들어, 한 클래스는 특정 파일 형식의 파일을 읽고, 다른 클래스는 같은 형식의 파일을 쓴다고 하자. [5.2, p.51-54] 어느 클래스도 인터페이스에서 파일 형식을 노출하지 않을 수 있지만, 둘 다 형식에 대한 지식을 가진다. [5.2, p.51-54] 형식이 변경되면 두 클래스 모두 수정해야 한다. [5.2, p.51-57]

뒷문 유출은 인터페이스를 통한 유출보다 **더 위험하다.** [5.2, p.56-57] 명확하지 않기 때문이다. [5.2, p.56-57]

#### 정보 유출의 해결
정보 유출을 발견하면 "이 지식을 이 특정 클래스에만 영향을 주도록 이 클래스들을 어떻게 재구성할 수 있을까?"라고 자문해야 한다. [5.2, p.60-67] 영향을 받은 클래스들이 상대적으로 작고 새는 정보와 밀접하게 관련되어 있다면, 단일 클래스로 병합하는 것이 좋을 수 있다. [5.2, p.62-64] 또 다른 가능한 접근은 새는 정보를 모든 영향을 받은 클래스에서 추출하여 정보만 캡슐화하는 새 클래스를 만드는 것이다. [5.2, p.64-68] 그러나 이 접근은 새 클래스가 세부 사항을 추상화하는 간단한 인터페이스를 찾을 수 있을 때만 효과적이다. [5.2, p.66-68] 새 클래스가 인터페이스를 통해 대부분의 지식을 노출하면, 인터페이스 유출을 뒷문 유출로 단순히 바꾼 것이므로 가치를 제공하지 못한다. [5.2, p.68-69]

### 3. 시간적 분해와 정보 유출

**시간적 분해**는 정보 유출의 일반적인 원인이다. [5.3, p.42-48] 시간적 분해에서는 시스템의 구조가 작업이 발생하는 시간 순서에 대응된다. [5.3, p.42-48]

#### 시간적 분해의 예

파일을 읽고, 내용을 수정한 다음, 수정된 버전을 쓰는 애플리케이션을 생각해보자. [5.3, p.44-48] 시간적 분해 스타일에서는 이를 세 개의 클래스로 나눌 것이다: [5.3, p.44-48]

1. 파일을 읽는 클래스
2. 내용을 수정하는 클래스
3. 수정된 내용을 쓰는 클래스

**문제**: 파일 읽기 및 쓰기 단계 모두에서 파일 형식에 대한 지식이 필요하므로 정보 유출이 발생한다. [5.3, p.49-57] 해결책은 파일 읽기 및 쓰기를 위한 핵심 메커니즘을 **단일 클래스에 결합하는 것**이다. [5.3, p.50-52] 이 클래스는 애플리케이션의 읽기 및 쓰기 단계 모두에서 사용된다. [5.3, p.50-52]

#### 핵심 원칙
모듈을 설계할 때는 **작업이 발생하는 순서가 아닌, 각 작업을 수행하는 데 필요한 지식에 집중해야 한다.** [5.3, p.61-63] 순서는 중요하지만, 애플리케이션의 수명 동안 여러 시점에서 나타나므로 구조에 반영되어서는 안 된다. [5.3, p.58-63]

### 4. HTTP 서버 구현: 정보 은닉 사례 분석

소프트웨어 설계 과정에서 학생들이 HTTP 프로토콜을 구현할 때, HTTP 요청을 처리하는 방식에서 학습해야 할 정보 은닉의 원칙이 많다. [5.4, p.40-53]

#### HTTP 요청 처리의 일반적인 실수: 너무 많은 클래스 [5.5, p.61-67]

가장 흔한 실수는 코드를 많은 얕은 클래스로 나누는 것이었다. [5.5, p.61-67] 한 팀은 HTTP 요청 수신을 위해 두 개의 서로 다른 클래스를 사용했다: [5.5, p.62-67]
- 첫 번째: 네트워크 연결에서 요청을 읽어 문자열에 넣음
- 두 번째: 요청 처리를 위해 문자열을 파싱

이는 시간적 분해의 예이다. [5.5, p.66-67] "먼저 요청을 읽고, 그 다음 파싱한다"

**정보 유출 발생**: HTTP 요청은 파싱 없이 읽을 수 없다. [5.5, p.38-45] 예를 들어, `Content-Length` 헤더는 요청 본문의 길이를 지정하므로, 총 요청 길이를 계산하려면 헤더를 파싱해야 한다. [5.5, p.38-45] 결과적으로 두 클래스 모두 HTTP 요청 구조에 대한 상당한 지식이 필요했고, 파싱 코드가 두 클래스에 복제되었다. [5.5, p.38-45]

이 접근은 호출자에게도 추가 복잡성을 만들었다. [5.5, p.43-45] 호출자는 두 개의 서로 다른 클래스에서 두 개의 메서드를 특정 순서로 호출해야 했다. [5.5, p.43-45]

**해결책**: 요청 읽기와 파싱을 단일 클래스로 병합하는 것이 훨씬 낫다. [5.5, p.46-50] 이는 더 나은 정보 은닉을 제공한다. [5.5, p.46-50] 요청 형식에 대한 모든 지식이 한 클래스에만 집중되고, 호출자는 단 하나의 메서드만 호출하면 된다. [5.5, p.46-50]

**일반 원칙**: 정보 은닉은 종종 **클래스를 조금 더 크게 만드는 것**으로 개선될 수 있다. [5.5, p.52-54] 한 가지 이유는 특정 기능과 관련된 모든 코드를 함께 가져오는 것이다. [5.5, p.52-54] 다른 이유는 인터페이스 수준을 올리기 위함이다. [5.5, p.56-58] 예를 들어, 계산의 세 단계 각각에 대한 별도 메서드가 아닌 전체 계산을 수행하는 단일 메서드가 더 단순한 인터페이스를 제공할 수 있다. [5.5, p.56-58]

#### HTTP 매개변수 처리 [5.6, p.36-101]

HTTP 요청 처리 후, 서버는 요청에서 정보에 접근해야 한다. [5.6, p.36-39] 학생 프로젝트 대부분은 매개변수 처리에서 두 가지 좋은 선택을 했다: [5.6, p.52-61]

1. 헤더 라인과 요청 본문의 구별을 숨김. 서버 애플리케이션이 매개변수가 헤더 라인인지 본문인지 신경 쓰지 않도록, HTTP 파서가 모든 위치의 매개변수를 병합함.
2. URL 인코딩 지식을 숨김. HTTP 파서가 반환하기 전에 매개변수 값을 디코드하므로, 서버는 URL 인코딩을 알 필요가 없음.

**문제 접근**: 그러나 대부분의 프로젝트는 매개변수 반환 인터페이스가 너무 얕았다. [5.6, p.62-64] 대부분은 `HTTPRequest` 객체를 사용했고, 다음과 같은 메서드를 가졌다: [5.6, p.64-69]

```java
public Map<String, String> getParams() {
    return this.params;
}
```

**문제점**: [5.6, p.70-87]
- 메서드는 단일 매개변수를 반환하지 않고, 모든 매개변수의 내부 Map에 대한 참조를 반환.
- `HTTPRequest` 클래스의 내부 표현을 노출.
- 표현이 변경되면(성능 개선 등), 인터페이스가 변경되고 모든 호출자가 수정 필요.
- 호출자가 `getParams`를 호출한 후 Map에서 특정 매개변수를 검색해야 함.
- 호출자가 `getParams`가 반환한 Map을 수정하면 `HTTPRequest`의 내부 상태가 영향을 받음.

**더 나은 인터페이스**: [5.6, p.88-101]

```java
public String getParameter(String name) { ... }
public int getIntParameter(String name) { ... }
```

- 더 깊은 인터페이스를 제공.
- 매개변수의 내부 표현을 숨김.
- `getIntParameter`는 문자열에서 정수로의 변환을 숨김. 호출자가 별도로 요청할 필요 없음.
- 다른 데이터 타입(`getDoubleParameter` 등)에 대한 추가 메서드 정의 가능.
- 메서드들은 매개변수가 존재하지 않거나 변환할 수 없으면 예외를 던짐.

#### HTTP 응답의 기본값 [5.7, p.25-57]

HTTP 응답 생성 지원을 제공할 때, 학생들이 흔히 범한 실수는 **불충분한 기본값**이었다. [5.7, p.25-28]

**예시 문제**: 한 팀이 호출자에게 HTTP 프로토콜 버전을 명시적으로 지정하도록 요청했다. [5.7, p.28-31] 그러나 응답 버전은 요청 객체의 버전과 일치해야 하며, 응답을 보낼 때 요청이 이미 인수로 전달되어 있으므로, HTTP 클래스에서 응답 버전을 자동으로 제공하는 것이 더 의미 있다. [5.7, p.28-31]

HTTP 응답도 응답이 전송되는 시간을 지정하는 Date 헤더를 포함해야 한다. [5.7, p.36-37] HTTP 라이브러리가 이에 대한 합리적인 기본값을 제공해야 한다. [5.7, p.42-44]

**일반 원칙**: 가능한 한 클래스는 명시적으로 요청받지 않고도 "올바른 일"을 해야 한다. [5.7, p.51-57] 기본값이 이를 예시한다. [5.7, p.45-47] 파일 I/O의 buffering처럼 보편적으로 바람직한 기능은 명시적으로 요청하지 않고도 자동으로 제공되어야 한다. [5.7, p.53-57] 최고의 기능은 그 존재를 알지 못하고도 얻는 것이다. [5.7, p.56-57]

### 5. 클래스 내 정보 은닉

정보 은닉은 외부 API 수준에만 적용되지 않는다. [5.8, p.62-68] 클래스 내에서도 적용될 수 있다. [5.8, p.62-68] 클래스의 private 메서드를 설계할 때, 각 메서드가 어떤 정보나 기능을 캡슐화하고 클래스의 나머지 부분으로부터 숨기도록 하자. [5.8, p.66-68] 또한 각 인스턴스 변수가 사용되는 위치의 수를 최소화하자. [5.8, p.68-72] 일부 변수는 클래스 전체에서 광범위하게 접근해야 할 수 있지만, 다른 변수는 몇 곳에서만 필요할 수 있다. [5.8, p.68-72] 변수 사용 위치의 수를 줄일 수 있으면 클래스 내의 의존성을 제거하고 복잡성을 줄인다. [5.8, p.68-72]

### 6. 정보 은닉의 한계 인식

정보 은닉은 숨겨진 정보가 모듈 외부에서 필요하지 않을 때만 의미가 있다. [5.9, p.42-53] 정보가 모듈 외부에서 필요하면, 은닉해서는 안 된다. [5.9, p.42-53]

예를 들어, 모듈의 성능이 특정 구성 매개변수의 영향을 받고 다양한 모듈 사용이 다른 설정을 요구한다면, 그 매개변수들이 모듈 인터페이스에 노출되는 것이 중요하다. [5.9, p.44-48] 소프트웨어 설계자로서, 모듈 외부에서 필요한 정보의 양을 최소화하려는 목표를 가져야 한다. [5.9, p.48-50] 예를 들어, 모듈이 자동으로 자신의 구성을 조정할 수 있다면, 구성 매개변수를 노출하는 것보다 낫다. [5.9, p.50-51] 그러나 모듈 외부에서 필요한 정보가 무엇인지 인식하고 그것이 노출되도록 해야 한다. [5.9, p.52-53]

### 7. 정보 은닉과 깊은 모듈의 관계

정보 은닉과 깊은 모듈은 밀접하게 관련되어 있다. [5.10, p.20-24] 모듈이 많은 정보를 숨기면, 일반적으로 모듈이 제공하는 기능의 양을 증가시키면서도 인터페이스를 줄인다. [5.10, p.20-24] 이는 모듈을 더 깊게 만든다. [5.10, p.20-24] 반대로, 모듈이 정보를 많이 숨기지 못하면, 기능이 거의 없거나 인터페이스가 복잡한 것이다. [5.10, p.24-25] 어느 쪽이든 모듈은 얕다. [5.10, p.24-25]

시스템을 모듈로 분해할 때, **작업이 런타임에 발생하는 순서의 영향을 받지 않도록 해야 한다.** [5.10, p.26-29] 이는 시간적 분해의 함정에 빠지는 경향이 있으며, 정보 유출과 얕은 모듈을 초래한다. [5.10, p.26-29] 대신, **응용 프로그램의 작업을 수행하는 데 필요한 다양한 지식 조각을 생각하고, 각 모듈이 그 지식의 하나 또는 몇 개를 캡슐화하도록 설계하자.** [5.10, p.29-32] 이는 정보 은닉이 명확하고 깊은 모듈을 가진 깨끗하고 단순한 설계를 만든다. [5.10, p.29-32]
