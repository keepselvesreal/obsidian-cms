---
version: 1.0
note: A Philosophy of Software Design - Chapter 4 Summary
creator: Haiku 4.5
created_time: 25-12-08 12:18
---

## 압축 내용

모듈을 설계할 때 가장 중요한 목표는 **모듈을 깊게(deep) 만드는 것**이다. 즉, 복잡하고 강력한 기능을 단순한 인터페이스 뒤에 숨기는 것이다. [4.4, p.38-39] 반대로 "클래스는 작아야 한다"는 통념이 낳은 "클래시티스(classitis)" 증후군은 많은 얕은 클래스를 만들어 전체 시스템 복잡성을 증가시킨다. [4.6, p.41-42]

---

## 핵심 내용

### 모듈 설계의 기본 원칙 (Modular Design)
모듈 설계는 개발자가 특정 시점에 전체 복잡성의 작은 부분만 직면하도록 시스템을 분해하는 접근 방식이다. [4.1, p.34] 각 모듈은 인터페이스(interface)와 구현(implementation)의 두 부분으로 구성되어 있다. [4.1, p.35] 인터페이스는 다른 모듈의 개발자가 그 모듈을 사용하기 위해 알아야 할 모든 것을 포함하고, 구현은 인터페이스의 약속을 수행하는 코드이다. [4.1, p.35]

### 깊은 모듈 vs 얕은 모듈 (Deep vs Shallow Modules)
**깊은 모듈**은 단순한 인터페이스 뒤에 강력한 기능을 제공한다. [4.4, p.38-39] Unix I/O 시스템 호출(open, read, write, lseek, close) 또는 Java/Go의 가비지 컬렉터가 좋은 예이다. [4.4, p.39-40] 깊은 모듈은 비용(인터페이스)과 이득(기능)의 비율이 좋으므로 전체 시스템 복잡성을 줄인다. [4.4, p.38]

**얕은 모듈**은 제공하는 기능에 비해 복잡한 인터페이스를 가진다. [4.5, p.40-41] 링크드 리스트 구현이나 단순히 내부 변수에 null을 저장하는 메서드가 예이다. [4.5, p.40-41] 얕은 모듈은 인터페이스 학습 비용이 제공하는 추상화 이득을 상쇄하므로 복잡성 관리에 도움이 되지 않는다. [4.5, p.41]

### 클래시티스 증후군 (Classitis)
"클래스는 작아야 한다"는 통념으로부터 발생한 문제이다. [4.6, p.41] 개발자들이 클래스당 최소 기능을 구현하는 경향은 많은 얕은 클래스를 만들고, 각 클래스의 인터페이스들이 누적되어 시스템 수준에서 엄청난 복잡성을 만든다. [4.6, p.41-42] Java I/O 라이브러리의 중첩된 스트림 객체 생성(`FileInputStream`, `BufferedInputStream`, `ObjectInputStream`)이 대표적인 예이다. [4.7, p.42]

---

## 상세 내용

### 목차
1. [모듈 설계의 개념과 인터페이스의 역할](#1-모듈-설계의-개념과-인터페이스의-역할)
2. [형식적 인터페이스와 비형식적 인터페이스](#2-형식적-인터페이스와-비형식적-인터페이스)
3. [추상화(Abstraction)의 정의와 중요성](#3-추상화abstraction의-정의와-중요성)
4. [깊은 모듈의 특성과 사례](#4-깊은-모듈의-특성과-사례)
5. [얕은 모듈의 문제점](#5-얕은-모듈의-문제점)
6. [클래시티스: 작은 클래스 신화의 문제](#6-클래시티스-작은-클래스-신화의-문제)
7. [Java와 Unix I/O 비교 분석](#7-java와-unix-io-비교-분석)
8. [설계의 핵심 원칙](#8-설계의-핵심-원칙)

---

### 1. 모듈 설계의 개념과 인터페이스의 역할

**모듈**은 인터페이스와 구현을 가진 코드의 단위이다. [4.1, p.52-56] 클래스, 메서드, 서브시스템, 서비스 등이 모두 모듈이다. [4.1, p.52-56]

모듈 설계의 핵심은 **의존성을 최소화하는 것**이다. [4.1, p.28-29] 이상적인 세계에서는 각 모듈이 완전히 독립적이어서 개발자가 한 모듈에서 다른 모듈을 알 필요 없이 작업할 수 있을 것이다. [4.1, p.16-18] 그러나 모듈들은 서로 호출하여 의존성이 생긴다. [4.1, p.20-23]

**인터페이스와 구현의 분리**는 의존성을 관리하는 핵심 전략이다. [4.1, p.35-44] 개발자는 자신이 작업하는 모듈의 인터페이스와 구현, 그리고 호출하는 다른 모듈의 인터페이스를 이해해야 한다. [4.1, p.41-43] 하지만 다른 모듈의 구현을 이해할 필요는 없다. [4.1, p.43-44]

균형 트리를 구현하는 모듈은 복잡한 내부 메커니즘(트리 균형 유지)을 가지지만, 사용자는 단순한 인터페이스(insert, remove, fetch)만 본다. [4.1, p.45-51]

**최고의 모듈은 인터페이스보다 구현이 훨씬 더 복잡한 모듈이다.** [4.1, p.62-69] 이런 모듈이 두 가지 장점을 제공한다. [4.1, p.63-69] 첫째, 단순한 인터페이스는 모듈이 나머지 시스템에 부과하는 복잡성을 최소화한다. [4.1, p.63-65] 둘째, 모듈의 인터페이스를 바꾸지 않는 방식으로 수정되면 다른 모듈은 영향을 받지 않는다. [4.1, p.65-67]

---

### 2. 형식적 인터페이스와 비형식적 인터페이스

모듈의 인터페이스는 두 가지 정보를 포함한다: 형식적(formal)과 비형식적(informal). [4.2, p.76-96]

**형식적 인터페이스**는 프로그래밍 언어에 의해 명시적으로 지정되고, 프로그래밍 언어가 정확성을 검증할 수 있는 부분이다. [4.2, p.78-84] 메서드의 서명(매개변수 이름, 타입, 반환값, 예외), 클래스의 공개 메서드와 변수 등이 포함된다. [4.2, p.78-85]

**비형식적 인터페이스**는 프로그래밍 언어로 지정되지 않지만, 모듈을 사용하기 위해 알아야 할 것들이다. [4.2, p.86-97] 함수의 고수준 동작(파일 삭제 등), 클래스 사용의 제약(한 메서드를 다른 메서드 이전에 호출해야 함 등)이 포함된다. [4.2, p.88-91] 비형식적 인터페이스는 주석으로만 표현 가능하고, 프로그래밍 언어는 완전성이나 정확성을 보장할 수 없다. [4.2, p.94-96]

**대부분의 인터페이스에서 비형식적 부분이 형식적 부분보다 크고 복잡하다.** [4.2, p.96-97]

명확히 지정된 인터페이스의 이점은 개발자가 모듈을 사용하기 위해 정확히 알아야 할 것이 무엇인지 나타낸다는 것이다. [4.2, p.98-101] 이는 2.2절에서 설명한 "미지의 미지" 문제를 해결하는 데 도움이 된다. [4.2, p.101]

---

### 3. 추상화(Abstraction)의 정의와 중요성

추상화는 복잡한 것의 단순화된 관점으로, 중요하지 않은 세부 사항을 생략한다. [4.3, p.103-106] 추상화는 복잡한 것을 생각하고 조작하기 쉽게 만든다. [4.3, p.105-106]

모듈 프로그래밍에서 각 모듈은 인터페이스 형태로 추상화를 제공한다. [4.3, p.43-47] 인터페이스는 모듈 기능의 단순화된 관점을 제시하고, 구현의 세부 사항은 생략한다. [4.3, p.43-47]

**추상화는 어떤 세부 사항이 중요한지 이해하는 것이 핵심이다.** [4.3, p.48-61] "중요하지 않은" 세부 사항을 많이 생략할수록 추상화가 좋다. [4.3, p.49-50] 그러나 중요한 세부 사항을 생략하면 **거짓 추상화(false abstraction)**가 된다. [4.3, p.51-61] 거짓 추상화는 단순해 보이지만 실제로는 그렇지 않다. [4.3, p.57-61]

추상화는 두 가지 방식으로 잘못될 수 있다. [4.3, p.51-61] 첫째, 정말 중요하지 않은 세부 사항을 포함하면 추상화가 필요 이상 복잡해져서 사용자의 인지 부하를 증가시킨다. [4.3, p.51-54] 둘째, 실제로 중요한 세부 사항을 생략하면 불명확성이 발생하고 사용자가 추상화를 올바르게 사용하지 못한다. [4.3, p.54-61]

파일 시스템의 추상화는 좋은 예이다. [4.3, p.62-72] 파일이 어느 디스크 블록에 저장되는지는 사용자에게 중요하지 않지만, 데이터가 언제 영구 저장소에 기록되는지는 데이터베이스에 중요하므로 인터페이스에 나타나야 한다. [4.3, p.62-72]

---

### 4. 깊은 모듈의 특성과 사례

모듈 깊이는 비용 대비 이득이다. [4.4, p.101-107] 모듈의 이득은 기능이고, 비용은 인터페이스이다. [4.4, p.101-107] 모듈의 인터페이스는 모듈이 나머지 시스템에 부과하는 복잡성을 나타낸다. [4.4, p.103-105] 인터페이스가 작고 단순할수록 모듈이 도입하는 복잡성이 적다. [4.4, p.103-105] **최고의 모듈은 가장 큰 이득을 제공하고 비용이 최소인 모듈이다.** [4.4, p.105-107]

**Unix I/O 인터페이스**는 깊은 모듈의 훌륭한 예이다. [4.4, p.36-79] 단 다섯 개의 기본 시스템 호출(open, read, write, lseek, close)만으로 파일 시스템의 모든 기능을 제공한다. [4.4, p.38-53] 각 호출의 서명은 단순하다. [4.4, p.38-43] open은 파일 경로를 받아 파일 디스크립터를 반환한다. [4.4, p.44-48] read와 write는 파일 디스크립터와 버퍼로 작동한다. [4.4, p.49-50] lseek은 무작위 접근을 지원한다. [4.4, p.50-53]

Unix I/O 구현은 **수십만 줄의 복잡한 코드를 포함한다.** [4.4, p.54-56] 파일이 디스크에 표현되는 방식, 디렉토리 저장, 계층적 경로 처리, 권한 강제, 파일 접근 구현, 동시 접근 스케줄링, 데이터 캐싱, 다양한 저장 장치 통합 등 많은 복잡한 문제를 처리한다. [4.4, p.55-71] 그러나 모든 복잡성은 프로그래머에게 숨겨진다. [4.4, p.76-79] Unix I/O 구현은 여러 해에 걸쳐 급격히 진화했지만, 다섯 가지 기본 호출은 변하지 않았다. [4.4, p.79]

**가비지 컬렉터**도 깊은 모듈의 좋은 예이다. [4.4, p.80-86] 이 모듈은 인터페이스가 없다(보이지 않게 작동). [4.4, p.81-82] 시스템에 가비지 컬렉션을 추가하면 실제로는 전체 인터페이스를 줄인다. [4.4, p.82-83] 메모리 해제 인터페이스를 제거하기 때문이다. [4.4, p.83-84] 가비지 컬렉터 구현은 매우 복잡하지만, 그 복잡성은 프로그래머로부터 숨겨진다. [4.4, p.84-86]

---

### 5. 얕은 모듈의 문제점

**얕은 모듈**은 인터페이스가 제공하는 기능에 비해 상대적으로 복잡하다. [4.5, p.91-98] 링크드 리스트 구현이 대표적이다. [4.5, p.92-98] 링크드 리스트를 조작하려면 코드가 거의 필요하지 않으므로(요소 삽입이나 삭제는 몇 줄), 링크드 리스트 추상화는 세부 사항을 많이 숨기지 못한다. [4.5, p.93-96]

**극단적인 예: 얕은 메서드**

```java
private void addNullValueForAttribute(String attribute) {
    data.put(attribute, null);
}
```

이 메서드는 복잡성 관리 측면에서 상황을 악화시킨다. [4.5, p.104-108] 메서드가 추상화를 제공하지 않기 때문이다. [4.5, p.105-106] 호출자는 데이터가 `data` 변수에 저장된다는 것을 알아야 한다. [4.5, p.106-107] 인터페이스를 생각하는 것이 전체 구현을 생각하는 것보다 더 간단하지 않다. [4.5, p.107-109] 메서드를 문서화하면 문서화가 메서드의 코드보다 더 길다. [4.5, p.44-46] 메서드를 호출하는 것이 직접 변수를 조작하는 것보다 더 많은 키스트로크를 필요로 한다. [4.5, p.46-47] 메서드는 복잡성을 추가하지만(새로운 인터페이스를 배워야 함) 보상하는 이득을 제공하지 않는다. [4.5, p.47-49]

### 6. 클래시티스: 작은 클래스 신화의 문제

프로그래밍의 종래의 지혜는 **"클래스는 작아야 한다"**이다. [4.6, p.56-59] 학생들은 더 큰 클래스를 작은 클래스로 나누는 것이 설계의 가장 중요한 것이라고 배운다. [4.6, p.58-61] 메서드도 마찬가지다: "10줄 이상의 모든 메서드는 여러 메서드로 나누어져야 한다"는 규칙을 받는다. [4.6, p.61-63] 이 접근 방식은 많은 얕은 클래스와 메서드를 생성하며, 이는 전체 시스템 복잡성을 증가시킨다. [4.6, p.63-65]

**클래시티스 증후군**은 "클래스는 좋으니 더 많은 클래스는 더 좋다"는 오류에서 비롯된다. [4.6, p.64-68] 클래시티스가 있는 시스템에서는 개발자들이 각 새 클래스의 기능을 최소화하도록 권장된다. [4.6, p.68-70] 더 많은 기능이 필요하면 더 많은 클래스를 도입한다. [4.6, p.70] 클래시티스는 개별 클래스를 단순하게 만들 수 있지만, **전체 시스템의 복잡성을 증가시킨다.** [4.6, p.70-73]

작은 클래스는 기능이 거의 없으므로 많은 수가 필요하고, 각각 자신의 인터페이스를 가진다. [4.6, p.70-72] 이 인터페이스들이 누적되어 **시스템 수준에서 엄청난 복잡성을 만든다.** [4.6, p.72-73] 작은 클래스는 또한 각 클래스에 필요한 표준 코드 때문에 문장이 장황해진다. [4.6, p.40-41]

---

### 7. Java와 Unix I/O 비교 분석

**Java I/O 라이브러리는 클래시티스의 명확한 예이다.** [4.7, p.43-53] Java 언어가 작은 클래스를 요구하지는 않지만, Java 프로그래밍 커뮤니티에서 클래시티스 문화가 확산되어 있다. [4.7, p.44-45]

serialized 객체를 읽기 위해 파일을 열려면 세 개의 서로 다른 객체를 생성해야 한다. [4.7, p.46-59]

```java
FileInputStream fileStream = new FileInputStream(fileName);
BufferedInputStream bufferedStream = new BufferedInputStream(fileStream);
ObjectInputStream objectStream = new ObjectInputStream(bufferedStream);
```

`FileInputStream`은 기본적인 I/O만 제공한다. [4.7, p.54-56] buffering이나 직렬화된 객체 읽기/쓰기를 할 수 없다. [4.7, p.55-57] `BufferedInputStream`이 `FileInputStream`에 buffering을 추가하고, `ObjectInputStream`이 읽기/쓰기 기능을 추가한다. [4.7, p.57-59] 첫 두 객체(`fileStream`, `bufferedStream`)는 파일이 열려도 다시 사용되지 않으며, 모든 향후 작업은 `objectStream`을 사용한다. [4.7, p.58-60]

Buffering을 명시적으로 요청해야 하는 것은 특히 성가시고 오류가 발생하기 쉽다. [4.7, p.60-62] 개발자가 `BufferedInputStream` 객체를 만들 수 없으면 buffering이 없고 I/O가 느려진다. [4.7, p.61-63]

Java 개발자들의 논리는 모든 사람이 buffering을 원하는 것은 아니므로 기본 메커니즘에 포함되지 않아야 한다는 것이다. [4.7, p.63-65] 선택이 좋지만, **인터페이스는 일반적인 경우를 최대한 단순하게 만들도록 설계되어야 한다.** [4.7, p.65-68] 거의 모든 파일 I/O 사용자가 buffering을 원하므로 기본적으로 제공되어야 한다. [4.7, p.68-70] buffering이 바람직하지 않은 드문 경우를 위해 라이브러리가 이를 비활성화하는 메커니즘을 제공할 수 있다. [4.7, p.70-72]

**Unix 시스템 호출 설계자들은 일반적인 경우를 단순하게 만들었다.** [4.7, p.47-54] 순차적 I/O가 가장 일반적이므로 기본 동작으로 만들었다. [4.7, p.48-50] 무작위 접근은 `lseek` 시스템 호출로 여전히 상대적으로 쉽지만, 순차 접근만 필요한 개발자는 이 메커니즘을 알 필요가 없다. [4.7, p.50-52] 인터페이스에 많은 기능이 있지만 대부분의 개발자가 소수의 기능만 필요로 한다면, 해당 인터페이스의 유효 복잡성은 일반적으로 사용되는 기능의 복잡성일 뿐이다. [4.7, p.52-54]

---

### 8. 설계의 핵심 원칙

모듈의 인터페이스를 구현으로부터 분리함으로써 구현의 복잡성을 나머지 시스템으로부터 숨길 수 있다. [4.8, p.56-59] 모듈 사용자는 인터페이스가 제공하는 추상화만 이해하면 된다. [4.8, p.58-61] 클래스와 다른 모듈을 설계할 때 **가장 중요한 문제는 모듈을 깊게 만드는 것**이다. [4.8, p.59-62] 즉, 일반적인 사용 사례에서 단순한 인터페이스를 가지면서도 중요한 기능을 제공해야 한다. [4.8, p.60-62] 이는 숨겨지는 복잡성의 양을 최대화한다. [4.8, p.62-63]

**모듈 깊이는 복잡성 관리의 핵심이다.** 많은 얕은 클래스를 많은 수의 얕은 메서드로 만드는 것보다, 깊은 클래스 몇 개로 큰 기능을 단순한 인터페이스 뒤에 숨기는 것이 훨씬 낫다.
