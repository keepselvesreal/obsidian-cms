---
version: 1.0
note: A Philosophy of Software Design - Chapter 8 Summary
creator: Haiku 4.5
created_time: 25-12-08 12:19
---

## 압축 내용

**복잡성을 아래로 내리기(Pull Complexity Downwards)**는 모듈이 일부 추가 고통을 감수해서 사용자의 고통을 줄이는 설계 철학이다. [8.4, p.25-26] 더 깊은 모듈을 만들기 위해서는 복잡한 기능을 모듈 내에 캡슐화하되, 사용자(호출자)가 그 복잡성을 인식하지 못하도록 해야 한다. [8.1, p.22-30]

---

## 핵심 내용

### 복잡성 이동의 트레이드오프
모듈 설계 시 두 가지 선택이 있다. [8.1, p.9-30] **복잡성을 아래로(내린다)**: 모듈이 추가 기능을 수행하여 사용자 인터페이스를 단순화한다. [8.1, p.22-30] **복잡성을 위로(올린다)**: 모듈이 불완전한 해결책을 제공하고 사용자가 나머지를 처리한다. [8.1, p.22-30] 첫 번째 접근이 전체 시스템 복잡성을 줄인다. [8.1, p.22-30]

### 구성 매개변수와 복잡성 상향
구성 매개변수는 복잡성을 위로 올리는 전형적인 예이다. [8.2, p.32-74] 모듈이 명시적으로 동작 방식을 결정하지 않고 매개변수로 내보낸다면, 사용자가 적절한 값을 지정해야 한다. [8.2, p.34-36] 그러나 사용자나 관리자가 올바른 값을 결정하기 어려운 경우가 많다. [8.2, p.54-56] **따라서 복잡성을 아래로 내려 모듈이 합리적인 기본값을 자동으로 결정하도록 하는 것이 낫다.** [8.2, p.68-75]

### 단계적 접근의 중요성
복잡성을 아래로 내리는 것은 신중하게 적용해야 하며, 과도하게 진행할 수 있는 방법이다. [8.3, p.81-90] 복잡성 이동은 (a) 내려지는 복잡성이 클래스의 기존 기능과 밀접하게 관련되어 있고, (b) 복잡성을 내리면 애플리케이션의 다른 곳에서 많은 단순화가 이루어지며, (c) 복잡성을 내리면 클래스의 인터페이스가 단순화될 때 가장 의미가 있다. [8.3, p.86-90]

---

## 상세 내용

### 목차
1. [복잡성 이동의 기본 개념](#1-복잡성-이동의-기본-개념)
2. [텍스트 에디터 예제: 문자 지향 인터페이스](#2-텍스트-에디터-예제-문자-지향-인터페이스)
3. [구성 매개변수와 복잡성 상향](#3-구성-매개변수와-복잡성-상향)
4. [복잡성을 아래로 내리는 원칙의 한계](#4-복잡성을-아래로-내리는-원칙의-한계)
5. [설계의 핵심 가이드](#5-설계의-핵심-가이드)

---

### 1. 복잡성 이동의 기본 개념

모듈을 개발할 때 중요한 질문은 **복잡성을 어디에 배치할 것인가**이다. [8.1, p.9-30] 두 가지 선택이 있다:

**첫째, 복잡성을 아래로 내린다**: [8.1, p.22-30]
- 모듈이 일부 추가 기능을 수행하여 사용자 인터페이스를 단순화한다.
- 결과적으로 모듈의 구현은 더 복잡해질 수 있지만, 전체 시스템 복잡성은 줄어든다.

**둘째, 복잡성을 위로 올린다**: [8.1, p.22-30]
- 모듈이 불완전한 해결책을 제공한다.
- 사용자(또는 상위 수준 모듈)가 복잡성을 처리한다.
- 이는 종종 모듈이 여러 매개변수를 내보내거나 사용자가 여러 단계를 수행하도록 요구한다.

**첫 번째 접근이 일반적으로 더 낫다.** [8.1, p.22-30] 모듈 개발자는 전체 문제를 이해하고, 최선의 해결책을 구현할 수 있다. [8.1, p.22-30] 사용자는 문제의 세부 사항을 알 필요가 없고, 높은 수준의 기능을 사용하기만 하면 된다. [8.1, p.22-30]

### 2. 텍스트 에디터 예제: 문자 지향 인터페이스 [8.1, p.8-30]

이 원칙을 설명하기 위해 GUI 텍스트 에디터의 텍스트 관리 클래스를 생각해보자. [8.1, p.9-12] 텍스트 클래스는 파일을 디스크에서 메모리로 읽고, 메모리상 사본을 쿼리 및 수정하며, 수정된 버전을 다시 디스크에 쓰는 메서드를 제공한다. [8.1, p.12-15]

#### 얕은 설계: 행 지향 인터페이스

많은 학생 구현에서는 **행 지향 인터페이스**를 선택했다. [8.1, p.13-20] 이 인터페이스는 전체 텍스트 라인을 읽고, 삽입하고, 삭제하는 메서드를 제공한다. [8.1, p.13-20] 이는 텍스트 클래스의 구현을 단순하게 한다. [8.1, p.15-17] 그러나 사용자 인터페이스 수준에서 작업은 전체 라인을 포함하지 않는다. [8.1, p.16-21] 예를 들어, 키 입력은 기존 라인 내의 개별 문자를 삽입한다. [8.1, p.16-19] 선택 영역을 복사하거나 삭제하는 것은 여러 라인의 부분을 수정할 수 있다. [8.1, p.19-21] 행 지향 인터페이스에서는 더 높은 수준의 소프트웨어가 라인을 분할하고 병합하여 사용자 인터페이스를 구현해야 한다. [8.1, p.19-22]

#### 깊은 설계: 문자 지향 인터페이스

대신 **문자 지향 인터페이스** (섹션 6.3에서 설명)를 사용하면 복잡성을 아래로 내린다. [8.1, p.22-30] 사용자 인터페이스 소프트웨어는 이제 라인을 분할하고 병합할 필요 없이 임의의 텍스트 범위를 삽입하고 삭제할 수 있다. [8.1, p.23-25] 따라서 더 단순해진다. [8.1, p.23-25]

텍스트 클래스의 구현은 아마도 더 복잡해진다. [8.1, p.25-26] 내부적으로 텍스트를 라인 모음으로 표현한다면, 문자 지향 작업을 구현하기 위해 라인을 분할하고 병합해야 한다. [8.1, p.25-26]

**그러나 이 접근이 더 낫다.** [8.1, p.28-30] 복잡성을 텍스트 클래스 내에 캡슐화하므로 전체 시스템 복잡성이 줄어든다. [8.1, p.28-30]

### 3. 구성 매개변수와 복잡성 상향 [8.2, p.31-75]

**구성 매개변수는 복잡성을 위로 올리는 흔한 방법이다.** [8.2, p.32-36]

#### 구성 매개변수의 개념

모듈이 명시적으로 동작 방식을 결정하지 않고, 대신 사용자가 튜닝할 수 있는 매개변수를 내보낼 수 있다. [8.2, p.34-36] 예를 들어, 캐시 크기, 요청 재시도 전 대기 시간 등이 있다. [8.2, p.34-36] 모듈 사용자는 매개변수에 적절한 값을 지정해야 한다. [8.2, p.36]

#### 구성 매개변수의 장점?

구성 매개변수 옹호자들은 이들이 좋다고 주장한다. [8.2, p.42-51] 이유는 사용자가 특정 요구 사항과 작업 부하에 대해 시스템을 튜닝할 수 있기 때문이다. [8.2, p.46-51] 일부 경우, 특정 작업에 가장 좋은 정책을 결정하기 어려울 수 있다. [8.2, p.46-51] 예를 들어, 어떤 요청이 다른 요청보다 시간이 더 오래 걸릴 수 있으므로 사용자가 그에 대한 우선순위를 지정할 수 있다. [8.2, p.46-51]

#### 구성 매개변수의 실제 문제점 [8.2, p.52-67]

그러나 구성 매개변수는 종종 **중요한 문제를 외면하고 다른 사람에게 넘기는 쉬운 핑계가 된다.** [8.2, p.52-56] 많은 경우, 사용자나 관리자가 매개변수의 올바른 값을 결정하기 어렵거나 불가능하다. [8.2, p.54-56]

다른 경우, 올바른 값을 모듈 구현에서 자동으로 결정할 수 있다. [8.2, p.56-62] 네트워크 프로토콜을 예로 생각해보자. [8.2, p.57-67] 프로토콜이 손실된 패킷을 처리해야 한다면, 요청을 재전송하기 전에 일정 시간을 기다려야 한다. [8.2, p.57-62] 한 가지 방법은 재시도 간격을 구성 매개변수로 도입하는 것이다. [8.2, p.57-62]

**더 나은 접근**: [8.2, p.62-67]
- 프로토콜이 **성공한 요청의 응답 시간을 측정**한다.
- 그 시간의 배수를 재시도 간격으로 사용한다.
- 이는 작업 조건이 변경되면 자동으로 재시도 간격을 조정한다.

이 접근은 **복잡성을 아래로 내린다.** [8.2, p.62-67] 사용자는 재시도 간격을 설정할 필요가 없다. [8.2, p.62-67] 모듈이 자동으로 합리적인 값을 계산한다. [8.2, p.62-67]

#### 구성 매개변수 피하기 [8.2, p.68-75]

따라서 **구성 매개변수를 최대한 피해야 한다.** [8.2, p.68-69] 구성 매개변수를 내보내기 전에 자문해야 한다: [8.2, p.69-71]

**"사용자(또는 상위 수준 모듈)가 우리보다 더 나은 값을 결정할 수 있을까?"**

구성 매개변수를 생성할 때는 사용자가 예외적인 조건에서만 값을 제공하도록 합리적인 기본값을 자동으로 계산할 수 있는지 확인하자. [8.2, p.71-72] 이상적으로, **각 모듈이 문제를 완전히 해결해야 한다.** [8.2, p.73-74] 구성 매개변수는 불완전한 해결책을 야기하며, 이는 시스템 복잡성을 증가시킨다. [8.2, p.74-75]

### 4. 복잡성을 아래로 내리는 원칙의 한계 [8.3, p.81-98]

**복잡성을 아래로 내리기는 신중하게 적용해야 한다.** [8.3, p.81-82] 이 원칙은 과도하게 진행될 수 있다. [8.3, p.82-84] 극단적인 접근은 애플리케이션의 전체 기능을 단일 클래스에 내리는 것인데, 이는 명백히 의미가 없다. [8.3, p.82-84]

**복잡성을 아래로 내리는 것이 의미 있는 조건**: [8.3, p.86-90]

1. **관련성**: 내려지는 복잡성이 클래스의 기존 기능과 밀접하게 관련되어 있어야 한다. [8.3, p.86-87]
2. **광범위한 단순화**: 복잡성을 내리면 애플리케이션의 다른 많은 곳에서 단순화가 이루어져야 한다. [8.3, p.87-88]
3. **인터페이스 단순화**: 복잡성을 내리면 클래스의 인터페이스가 단순화되어야 한다. [8.3, p.88-89]

#### 반례: 과도한 복잡성 이동

학생 프로젝트에서는 텍스트 클래스에 사용자 인터페이스 관련 메서드(예: 백스페이스 키 기능 구현)를 추가했다. [8.3, p.91-93] 이는 복잡성을 아래로 내리는 것처럼 보이지만, **사실 정보 유출이다.** [8.3, p.97-98]

사용자 인터페이스 지식을 텍스트 클래스에 추가해도 더 높은 수준의 코드가 많이 단순화되지 않으며, 사용자 인터페이스 지식은 텍스트 클래스의 핵심 기능과 관련이 없다. [8.3, p.94-97] 이 경우, 복잡성을 아래로 내리는 것은 정보 유출만 야기한다. [8.3, p.97-98]

### 5. 설계의 핵심 가이드 [8.4, p.99-26]

모듈을 개발할 때, **사용자의 고통을 줄이기 위해 자신이 조금 더 고통받을 기회를 찾자.** [8.4, p.25-26] 이 철학은 다음과 같이 표현된다:

> "When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users."

이것은 좋은 모듈 설계의 핵심이다. 복잡성을 아래로 내려 사용자 인터페이스를 단순화하되, 그 과정에서 모듈의 구현은 더 복잡해질 수 있다는 것을 이해하는 것이다.
