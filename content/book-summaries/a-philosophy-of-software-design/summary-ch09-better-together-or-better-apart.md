---
version: 1.0
note: A Philosophy of Software Design - Chapter 9 Summary
creator: Haiku 4.5
created_time: 25-12-08 12:20
---

## 압축 내용

두 기능을 함께 구현할지 분리할지 결정할 때, **복잡성 최소화가 목표**이다. [9.0, p.75] 많은 작은 컴포넌트로 나누면 개별 컴포넌트는 단순하지만 시스템 복잡성이 증가할 수 있다. [9.0, p.49-56] **분리와 결합 결정은 정보 은닉, 의존성, 인터페이스 깊이를 고려하여 전체 시스템 복잡성이 최소화되는 구조를 선택해야 한다.** [9.9, p.14-16]

---

## 핵심 내용

### 분할의 복잡성 증가
시스템을 많은 작은 컴포넌트로 나누는 것이 최선이라고 가정할 수 있지만, 분할 자체가 새로운 복잡성을 만든다. [9.0, p.49-56] **컴포넌트의 개수 증가로 인한 복잡성**: 컴포넌트가 많을수록 추적하고 관리하기 어렵다. [9.0, p.51-53] **인터페이스 증가**: 분할은 일반적으로 더 많은 인터페이스를 만들고, 새로운 인터페이스는 모두 복잡성을 추가한다. [9.0, p.54-56] **추가 관리 코드**: 분할된 컴포넌트를 관리하는 코드가 필요할 수 있다. [9.0, p.56-57]

### 정보 공유 시 결합
정보가 여러 모듈에서 공유된다면, 모듈을 결합하는 것이 낫다. [9.1, p.6-21] HTTP 요청 처리 예에서, 읽기와 파싱 모두 HTTP 요청 형식에 대한 지식이 필요했으므로, 한 모듈로 결합하면 코드가 짧아지고 단순해진다. [9.1, p.6-21]

### 인터페이스 단순화를 위한 결합
모듈을 결합하면 새로운 인터페이스가 원래의 인터페이스보다 단순하고 사용하기 쉬울 수 있다. [9.2, p.23-36] Java I/O에서 `FileInputStream`과 `BufferedInputStream`을 결합하고 buffering을 기본으로 제공하면, 대부분의 사용자는 buffering의 존재를 알 필요가 없다. [9.2, p.32-43]

### 일반 목적 및 특수 목적 코드 분리
일반 목적 메커니즘과 그것을 특정 용도로 특화하는 코드는 분리되어야 한다. [9.4, p.31-72] 특수 목적 코드는 상위 계층에서 일반 목적 코드 위에 계층화되어야 한다. [9.4, p.63-72]

---

## 상세 내용

### 목차
1. [분할의 복잡성 트레이드오프](#1-분할의-복잡성-트레이드오프)
2. [모듈 결합/분리의 판단 기준](#2-모듈-결합분리의-판단-기준)
3. [정보 공유에 기반한 결합](#3-정보-공유에-기반한-결합)
4. [인터페이스 단순화를 위한 결합](#4-인터페이스-단순화를-위한-결합)
5. [중복 제거](#5-중복-제거)
6. [일반 목적/특수 목적 코드 분리](#6-일반-목적특수-목적-코드-분리)
7. [삽입 커서와 선택의 예](#7-삽입-커서와-선택의-예)
8. [로깅 클래스의 예](#8-로깅-클래스의-예)
9. [Undo 메커니즘의 예](#9-undo-메커니즘의-예)
10. [메서드 분할/결합 원칙](#10-메서드-분할결합-원칙)

---

### 1. 분할의 복잡성 트레이드오프 [9.0, p.33-57]

모듈 설계에서 가장 근본적인 질문 중 하나는: **두 기능을 같은 곳에서 구현할지, 아니면 분리할지?** [9.0, p.33-37] 이는 함수, 메서드, 클래스, 서비스 등 모든 수준에서 적용된다. [9.0, p.37-38]

#### 직관적인 가정의 문제

시스템을 많은 작은 컴포넌트로 나누는 것이 최선이라고 가정할 수 있다. [9.0, p.47-50] 컴포넌트가 작을수록 각 개별 컴포넌트가 단순할 것이라고 생각할 수 있다. [9.0, p.47-50] 그러나 **분할 행위 자체가 이전에 없던 복잡성을 만든다.** [9.0, p.50-57]

#### 분할이 만드는 새로운 복잡성

**1. 컴포넌트 개수 증가로 인한 복잡성**: [9.0, p.51-53]
- 컴포넌트가 많을수록 모두를 추적하기 어렵다.
- 많은 컴포넌트의 모음에서 원하는 컴포넌트를 찾기 어렵다.

**2. 인터페이스 증가**: [9.0, p.54-56]
- 분할은 일반적으로 더 많은 인터페이스를 만든다.
- 새로운 인터페이스는 모두 복잡성을 추가한다.

**3. 추가 관리 코드**: [9.0, p.56-57]
- 단일 객체를 사용하는 코드를 여러 컴포넌트를 관리하는 코드로 변경하면 추가 코드가 필요하다.

### 2. 모듈 결합/분리의 판단 기준 [9.0, p.45-56]

시스템의 전체 복잡성을 감소시키고 모듈화를 개선하는 것이 목표이다. [9.0, p.45-47] 이를 위해서는 어떤 구조가 **정보 은닉이 최고, 의존성이 최소, 인터페이스가 가장 깊은 구조**인지 판단해야 한다. [9.9, p.14-16]

### 3. 정보 공유에 기반한 결합 [9.1, p.6-21]

기본 규칙: **여러 모듈에서 정보가 공유된다면, 그들을 결합하는 것이 낫다.** [9.1, p.6-21]

#### HTTP 요청 처리 예제 [9.1, p.6-21]

HTTP 서버 프로젝트의 첫 번째 구현에서는 HTTP 요청을 받기 위해 두 개의 다른 메서드(다른 클래스)를 사용했다: [9.1, p.9-15]

1. 첫 번째: 네트워크 연결에서 요청을 읽어 문자열 객체에 넣음
2. 두 번째: 요청 컴포넌트를 추출하기 위해 문자열 파싱

**정보 유출 발생**: [9.1, p.15-18]
- 두 메서드 모두 HTTP 요청 형식에 대한 상당한 지식이 필요
- 첫 번째 메서드가 읽기만 하려고 하지만, 요청 끝을 식별할 수 없음
- 예를 들어, `Content-Length` 헤더를 파싱해야 함

**해결책**: [9.1, p.19-21]
- 읽기와 파싱을 같은 곳에 결합
- 두 클래스를 병합
- 코드는 더 짧고 단순해짐

### 4. 인터페이스 단순화를 위한 결합 [9.2, p.23-43]

두 개 이상의 모듈을 결합하면, 원래 인터페이스보다 단순하거나 사용하기 쉬운 새로운 인터페이스를 정의할 수 있다. [9.2, p.23-26] 이는 원래 모듈이 각각 문제의 일부를 구현할 때 특히 발생한다. [9.2, p.25-26]

#### HTTP 서버 예제 [9.2, p.26-30]
원래 메서드는 첫 번째 메서드에서 HTTP 요청 문자열을 반환하는 인터페이스가 필요했고, 두 번째 메서드에 이를 전달해야 했다. [9.2, p.27-29] 메서드를 결합하면 이 인터페이스가 제거된다. [9.2, p.29-30]

#### Java I/O 예제 [9.2, p.31-43]
기능을 결합할 때, 대부분의 사용자가 인식할 필요가 없도록 일부 기능을 자동으로 수행할 수 있다. [9.2, p.31-36] Java I/O에서 `FileInputStream`과 `BufferedInputStream` 클래스를 결합하고 buffering을 기본으로 제공하면, [9.2, p.32-36] 대다수의 사용자는 buffering의 존재를 알 필요가 없다. [9.2, p.35-36] 결합된 `FileInputStream` 클래스는 buffering을 비활성화하는 메서드를 제공할 수 있지만, 대부분의 사용자는 이에 대해 알 필요가 없다. [9.2, p.41-43]

### 5. 중복 제거 [9.3, p.44-66]

코드의 같은 패턴이 반복된다면, 코드 반복을 제거하는 방법을 찾자. [9.3, p.45-49] 한 가지 접근은 반복된 코드를 별도의 메서드로 추출하고, 반복된 코드를 메서드 호출로 바꾸는 것이다. [9.3, p.45-49]

**효과적인 조건**: [9.3, p.48-54]
- 반복된 코드 스니펫이 길 때
- 반신 메서드의 서명이 단순할 때

**덜 효과적인 경우**: [9.3, p.50-54]
- 스니펫이 1-2줄일 때
- 스니펫이 환경과 복잡하게 상호 작용할 때(많은 로컬 변수 접근 등)

#### 다른 제거 방법 [9.3, p.55-66]
중복을 제거하는 다른 방법은 코드를 재구성하여 스니펫이 한 곳에서만 실행되도록 하는 것이다. [9.3, p.55-66] 예를 들어, 여러 지점에서 error return이 필요한 메서드의 경우, cleanup 코드를 메서드 끝에 이동하고 각 error 지점에서 그것으로 goto할 수 있다. [9.3, p.59-66]

### 6. 일반 목적/특수 목적 코드 분리 [9.4, p.30-72]

모듈이 여러 목적에 사용될 수 있는 메커니즘을 포함한다면, **그것은 단지 그 일반 목적 메커니즘을 제공해야 한다.** [9.4, p.31-39] 특정 사용을 위해 메커니즘을 특화하는 코드는 별도 모듈(일반적으로 특정 목적과 연관된 모듈)에 있어야 한다. [9.4, p.31-39]

#### 계층화 원칙 [9.4, p.63-72]

일반적으로, 시스템의 **하위 계층은 더 일반 목적이고 상위 계층은 더 특수 목적이다.** [9.4, p.63-67] 특수 목적 코드를 일반 목적 코드에서 분리하는 방법은 특수 목적 코드를 상위 계층으로 끌어올리는 것이다. [9.4, p.66-67] 이는 하위 계층을 일반 목적으로 유지한다. [9.4, p.66-67]

일반 목적과 특수 목적 기능이 같은 추상화를 위한 클래스에 포함되어 있다면, 클래스를 두 개로 분리할 수 있는지 확인하자. [9.4, p.68-72] 하나는 일반 목적 기능을 포함하고, 다른 하나는 그것 위에 계층화되어 특수 목적 기능을 제공한다. [9.4, p.68-72]

### 7. 삽입 커서와 선택의 예 [9.5, p.73-81]

GUI 에디터에서 삽입 커서와 선택은 관련이 있어 보인다: [9.5, p.78-80]
- 커서는 항상 보임
- 선택이 있으면 커서는 항상 선택의 한 끝에 위치
- 마우스 클릭과 드래그로 둘 다 설정
- 텍스트 삽입이 먼저 선택을 삭제한 다음 커서 위치에 삽입

한 팀이 이들을 단일 객체로 관리했다. [9.5, p.80-81] 객체는 두 위치를 저장하고, 커서와 선택의 끝을 나타내는 부울 값을 저장했다. [9.5, p.80-81]

**문제점**: [9.5, p.45-55]
- 결합된 객체는 더 높은 수준의 코드에 이득을 제공하지 않음
- 더 높은 수준은 여전히 선택과 커서를 별개 엔티티로 인식하고 분리적으로 조작
- 구현이 분리된 객체보다 더 복잡함
- 높은 수준의 코드는 여전히 두 개의 메서드를 호출해야 함

**해결책**: [9.5, p.68-81]
- 선택과 커서를 분리하기
- 둘 다 단순해짐 (사용과 구현 모두)
- 개정된 버전에서 `Position` 클래스를 도입
- 선택: 두 개의 위치
- 커서: 한 개의 위치
- `Position`이 다른 곳에서도 사용되는 일반 목적 구조가 됨

이 예는 **더 깊고 일반 목적의 인터페이스의 이점**도 보여준다. [9.5, p.79-81]

### 8. 로깅 클래스의 예 [9.6, p.27-75]

학생 프로젝트에서, 특정 오류별로 오류를 로깅하는 메서드가 있는 `NetworkErrorLogger` 클래스가 있었다: [9.6, p.44-61]

```java
private static class NetworkErrorLogger {
    public static void logRpcOpenError(RpcRequest req, AddrPortTuple dest, Exception e) {
        logger.log(Level.WARNING, "Cannot send message: " + req + ...);
    }
}
```

**문제점**: [9.6, p.61-75]
- 로깅 메서드가 얕음 (한 줄 코드)
- 상당한 문서화 필요
- 각 메서드가 단 한 곳에서만 호출됨
- 로깅 메서드에 대한 높은 의존성 (호출 위치를 이해하려면 메서드를 봐야 함)

**해결책**: [9.6, p.72-74]
- 로깅 메서드를 제거
- 로깅 문을 오류가 감지된 위치에 직접 배치
- 코드가 읽기 쉬워짐
- 로깅 메서드의 인터페이스가 필요 없음

### 9. Undo 메커니즘의 예 [9.7, p.81-107]

GUI 에디터 프로젝트에서, 일부 학생은 전체 undo 메커니즘을 텍스트 클래스의 일부로 구현했다. [9.7, p.89-113]

#### 문제된 설계 [9.7, p.89-113]

텍스트 클래스가 undo 메커니즘의 핵심(action 목록 관리)과 특수 목적 처리(텍스트 변경, 선택 변경 등)를 모두 포함했다. [9.7, p.100-113]

**문제점**:
- 특수 목적 undo 처리(선택, 커서)는 텍스트 클래스의 다른 것과 무관
- 텍스트 클래스와 사용자 인터페이스 간 정보 유출
- 새로운 undoable 엔티티 추가 시 텍스트 클래스 수정 필요
- 일반 목적 undo 코어가 특수 목적 처리와 섞여 있음

#### 해결책: 역할 분리 [9.7, p.44-107]

일반 목적 undo 코어를 별도 `History` 클래스로 추출: [9.7, p.44-88]

```java
public class History {
    public interface Action {
        public void redo();
        public void undo();
    }
    void addAction(Action action) { ... }
    void addFence() { ... }
    void undo() { ... }
    void redo() { ... }
}
```

**설계의 이점**:
- `History` 클래스: 일반 목적 메커니즘 (action 목록 관리, undo/redo 진행)
- `History.Action` 구현: 특수 목적 (각 종류의 action 이해)
- 상위 계층 코드: grouping 정책 결정

**역할 분리**: [9.7, p.89-107]

1. **일반 목적 메커니즘**: 실행된 action 목록 관리 및 undo/redo 진행 (`History` 클래스에서)
2. **특수 목적 처리**: 특정 action 종류 처리 (`History.Action` 구현에서)
3. **정책**: action grouping 방식 (상위 계층 코드에서)

**각 부분이 독립적으로 이해 가능**: [9.7, p.99-107]
- `History` 클래스는 어떤 action이 undo되는지 모름
- Action 구현은 `History`나 grouping 정책을 알 필요 없음
- 상위 계층은 `History` 구현을 이해할 필요 없음

**주의**: [9.7, p.108-125]
- 일반 목적 코드와 특수 목적 코드 분리는 같은 메커니즘 내에서만 적용
- 한 메커니즘의 특수 목적 코드를 다른 메커니즘의 일반 목적 코드와 결합하는 것은 OK
- 예: 텍스트 클래스는 일반 목적 텍스트 관리이지만, 특수 목적 undo 코드 포함 가능
- 그 undo 코드는 `History` 클래스의 일반 목적 undo 인프라와 결합되지 않음

### 10. 메서드 분할/결합 원칙 [9.8, p.126-150]

메서드도 클래스와 마찬가지로 분할/결합 결정을 해야 한다. [9.8, p.126-140]

#### 메서드 분할의 잘못된 기준

**길이 자체는 나쁜 이유가 아니다.** [9.8, p.134-140] "20줄 이상의 메서드는 분할하라"는 엄격한 규칙은 문제가 있다. [9.8, p.132-134]

**긴 메서드가 괜찮은 경우**: [9.8, p.141-151]
- 다섯 개의 20줄 코드 블록이 순서대로 실행되고, 블록이 상대적으로 독립적일 때
- 블록이 복잡한 상호 작용을 하면, 분할해서는 안 됨 (이해를 위해 모두 함께 봐야 함)
- 수백 줄의 메서드도 OK (간단한 서명, 읽기 쉬움)

#### 메서드 분할의 올바른 기준

**메서드 설계의 가장 중요한 목표**: 깨끗하고 단순한 추상화 제공. [9.8, p.48-54] 각 메서드는 한 가지를 완전히 하고, [9.8, p.49-52] 깨끗하고 단순한 인터페이스를 가져야 하며, [9.8, p.50-52] 깊어야 한다 (인터페이스가 구현보다 훨씬 더 간단). [9.8, p.52-54]

메서드를 분할하는 것은 더 깨끗한 추상화를 만들 때만 의미가 있다. [9.8, p.55-97] 두 가지 방법이 있다: [9.8, p.55-97]

**방법 1: 하위 작업 추출** [9.8, p.55-71]
- 분리 가능한 하위 작업을 메서드로 추출
- 자식 메서드가 부모를 이해할 필요 없고, 부모가 자식 구현을 이해할 필요 없을 때 의미 있음
- 자식 메서드가 일반 목적이어야 함 (다른 곳에서도 사용 가능)
- 부모와 자식 간 왕복하며 이해해야 한다면 "Conjoined Methods" red flag

**방법 2: 기능 분할** [9.8, p.77-97]
- 원래 메서드를 여러 개의 더 작은 메서드로 분할 (호출자가 visible)
- 이는 원래 메서드가 관련 없는 여러 것을 하려고 할 때만 의미 있음
- 각 새로운 메서드의 인터페이스가 원래보다 단순해야 함
- 대부분의 호출자가 하나의 새로운 메서드만 호출해야 함 (둘 다 호출하면 복잡성 증가)
- 새로운 메서드가 더 일반 목적이어야 함

#### 메서드 결합

메서드 분할이 아닌 **결합**으로 시스템을 단순하게 만들 수도 있다. [9.8, p.98-105] 결합이 도움이 되는 경우: [9.8, p.98-105]
- 두 개의 얕은 메서드를 하나의 더 깊은 메서드로 대체
- 코드 중복 제거
- 원래 메서드 간 의존성 제거
- 더 나은 캡슐화 (여러 곳에 있던 지식이 한 곳에 집중)
- 더 단순한 인터페이스

### 11. 최종 결정 기준 [9.9, p.13-16]

모듈을 분할할지 결합할지 결정은 **전체 시스템 복잡성을 최소화하는 구조**에 기반해야 한다. [9.9, p.14-16] **정보 은닉이 최고**, **의존성이 최소**, **인터페이스가 가장 깊은 구조를 선택하자.** [9.9, p.14-16]
